[
    {
        "id": "invoice-duplicate-detector",
        "name": "Invoice Duplicate Detector",
        "description": "Detects duplicate invoices based on invoice number, vendor, and amount to prevent payment errors",
        "category": "Finance & Accounting",
        "icon": "Search",
        "template": {
            "prompt": "You are an invoice duplicate detection specialist. Find duplicate invoices in the database by grouping invoices that have the same invoice number, vendor, and total amount. Show the count of duplicates and list all instances with invoice details, vendor information, dates, and amounts. Use postgres_inspect_schema first to understand the schema.",
            "trigger_type": "scheduled",
            "input_fields": [],
            "tools": [
                "postgres_query",
                "postgres_inspect_schema"
            ],
            "default_visualization_preferences": "pie chart showing duplicate count distribution by vendor, bar chart comparing duplicate counts",
            "execution_guidance": {
                "query_template": {
                    "base_query": "SELECT\n  STRING_AGG(d.batch_name, ', ') AS batch_names,\n  (i.invoice_number->>'value')::text AS invoice_number,\n  (i.total->>'value')::text AS total,\n  v.name AS vendor_name,\n  COUNT(*) AS duplicate_count\nFROM icap_invoice i\nLEFT JOIN icap_vendor v ON i.vendor_id = v.id\nINNER JOIN icap_document d ON i.document_id = d.id\nWHERE (i.total->>'value') IS NOT NULL AND (i.total->>'value') <> ''\nGROUP BY d.batch_name, invoice_number, total, vendor_name\nHAVING COUNT(*) > 1\nORDER BY duplicate_count DESC;",
                    "where_clause": "",
                    "parameters": [],
                    "param_instructions": "No parameters required - scans all invoices.",
                    "full_template": "SELECT\n  STRING_AGG(d.batch_name, ', ') AS batch_names,\n  (i.invoice_number->>'value')::text AS invoice_number,\n  (i.total->>'value')::text AS total,\n  v.name AS vendor_name,\n  COUNT(*) AS duplicate_count\nFROM icap_invoice i\nLEFT JOIN icap_vendor v ON i.vendor_id = v.id\nINNER JOIN icap_document d ON i.document_id = d.id\nWHERE (i.total->>'value') IS NOT NULL AND (i.total->>'value') <> ''\nGROUP BY invoice_number, total, vendor_name\nHAVING COUNT(*) > 1\nORDER BY duplicate_count DESC;"
                },
                "execution_plan": {
                    "step_1": "Load pre-built query template from execution_guidance",
                    "step_2": "No parameters required - scans all invoices.",
                    "step_3": "Execute query directly using postgres_query tool",
                    "step_4": "Structure results as table_data with columns and rows arrays",
                    "step_5": "Include row_count and column metadata",
                    "step_6": "Return formatted table for interactive display"
                },
                "schema_context": "The database has been pre-inspected for your task. Key tables and columns:\n\n**Table: icap_invoice**\n- Columns (22): id, document_id, vendor_id, other_charges, credit_and_returns, invoice_number, invoice_date, due_date, tax, freight_charges, discount, total, sub_total, street, zip, city, country, state, payment_date, balance_amount, created_at, updated_at\n- JSONB columns (require ->> operator): other_charges, credit_and_returns, invoice_number, invoice_date, due_date, tax, freight_charges, discount, total, sub_total, street, zip, city, country, state, payment_date, balance_amount\n- Joins with: document_id \u2192 icap_document, vendor_id \u2192 icap_vendor\n- Related detail tables: icap_invoice_detail\n\n**Table: icap_vendor**\n- Columns (11): id, tenant_id, name, company, address, email, active, created_by, modified_by, created_on, modified_on\n- Related detail tables: icap_invoice, icap_product_master\n\n\u26a0\ufe0f IMPORTANT: This is just a preview. You must still call postgres_inspect_schema() for each table before writing queries to get complete column lists and relationships.",
                "generated_at": "2026-01-02T18:45:00.000000",
                "configuration": {
                    "trigger_type": "scheduled",
                    "output_format": "text",
                    "prompt": "You are an invoice duplicate detection specialist. Find duplicate invoices in the database by grouping invoices that have the same invoice number, vendor, and total amount. Show the count of duplicates and list all instances with invoice details, vendor information, dates, and amounts. Use postgres_inspect_schema first to understand the schema."
                }
            }
        },
        "use_cases": [
            "Prevent duplicate payments",
            "Audit invoice records",
            "Clean up invoice database"
        ]
    },
    {
        "id": "invoice-approval-router",
        "name": "Invoice Auto-Approver (Confidence-Based)",
        "description": "Auto-approves invoices where all critical field confidence scores >= threshold (invoice + line items)",
        "category": "Workflow Management",
        "icon": "CheckCircle",
        "template": {
            "prompt": "You are an AI-driven invoice auto-approval agent.\n\nValidation Criteria:\n1. From icap_invoice (3 fields): invoice_number, invoice_date, due_date\n2. From icap_invoice_detail (3 fields): description, quantity, unit_price\n3. vendor_id is UUID (NO confidence check - skip it)\n4. ALL 6 JSONB fields must have confidence >= threshold\n5. Check BOTH header and ALL line items\n\nQuery Logic:\n- Join icap_invoice with icap_invoice_detail on document_id\n- Extract confidence: (column->>'confidence')::numeric\n- Filter: ALL 6 fields >= threshold\n- Update icap_document.status = (SELECT id FROM icap_workflow_status WHERE status_code = 'Bill_Export_In_Progress') for qualifying invoices\n- Use dry-run workflow\n\nDefault threshold: 95.0",
            "trigger_type": "conditions",
            "input_fields": [
                {
                    "name": "threshold",
                    "type": "text",
                    "label": "Threshold (%)",
                    "description": "Enter the confidence threshold percentage (e.g., 95.0 for 95%)"
                }
            ],
            "output_format": "text",
            "tools": [
                "postgres_query",
                "postgres_inspect_schema",
                "postgres_write"
            ],
            "default_visualization_preferences": "bar chart showing confidence scores distribution, pie chart by validation status",
            "execution_guidance": {
                "query_template": {
                    "base_query": "WITH invoice_detail_confidence AS (\n    SELECT \n        ivd.document_id,\n        MIN((ivd.description->>'confidence')::numeric) AS min_desc_conf,\n        MIN((ivd.quantity->>'confidence')::numeric) AS min_qty_conf,\n        MIN((ivd.unit_price->>'confidence')::numeric) AS min_price_conf,\n        COUNT(*) AS line_count\n    FROM icap_invoice_detail ivd\n    GROUP BY ivd.document_id\n    HAVING MIN((ivd.description->>'confidence')::numeric) >= {threshold}\n        AND MIN((ivd.quantity->>'confidence')::numeric) >= {threshold}\n        AND MIN((ivd.unit_price->>'confidence')::numeric) >= {threshold}\n)\nSELECT\n    d.batch_name,\n    d.accuracy,\n    (i.invoice_number->>'value')::text AS invoice_number,\n    (i.invoice_number->>'confidence')::numeric AS inv_num_conf,\n    (i.invoice_date->>'value')::text AS invoice_date,\n    (i.invoice_date->>'confidence')::numeric AS inv_date_conf,\n    (i.due_date->>'value')::text AS due_date,\n    (i.due_date->>'confidence')::numeric AS due_date_conf,\n    v.name AS vendor_name,\n    idc.line_count,\n    idc.min_desc_conf,\n    idc.min_qty_conf,\n    idc.min_price_conf,\n    LEAST(\n        (i.invoice_number->>'confidence')::numeric,\n        (i.invoice_date->>'confidence')::numeric,\n        (i.due_date->>'confidence')::numeric,\n        idc.min_desc_conf,\n        idc.min_qty_conf,\n        idc.min_price_conf\n    ) AS overall_min_confidence,\n    d.status\nFROM icap_invoice i\nLEFT JOIN icap_vendor v ON i.vendor_id = v.id\nINNER JOIN icap_document d ON i.document_id = d.id\nINNER JOIN invoice_detail_confidence idc ON i.document_id = idc.document_id\nWHERE d.status = 2 AND d.sub_status = 15\n  AND (i.invoice_number->>'confidence')::numeric >= {threshold}\n  AND (i.invoice_date->>'confidence')::numeric >= {threshold}\n  AND (i.due_date->>'confidence')::numeric >= {threshold}\nORDER BY overall_min_confidence DESC;",
                    "parameters": [
                        "threshold"
                    ],
                    "param_instructions": "Extract 'threshold' from user query (e.g., 'confidence above 90' -> 90.0, 'accuracy 85%' -> 85.0). Default: 95.0",
                    "description": "Validates 6 critical fields: invoice_number, invoice_date, due_date (header) + description, quantity, unit_price (ALL line items). vendor_id is UUID - no confidence check.",
                    "where_clause": "WHERE d.status = 2 AND d.sub_status = 15 AND all 6 JSONB fields >= {threshold}",
                    "full_template": "WITH invoice_detail_confidence AS (\n    SELECT \n        ivd.document_id,\n        MIN((ivd.description->>'confidence')::numeric) AS min_desc_conf,\n        MIN((ivd.quantity->>'confidence')::numeric) AS min_qty_conf,\n        MIN((ivd.unit_price->>'confidence')::numeric) AS min_price_conf,\n        COUNT(*) AS line_count\n    FROM icap_invoice_detail ivd\n    GROUP BY ivd.document_id\n    HAVING MIN((ivd.description->>'confidence')::numeric) >= {threshold}\n        AND MIN((ivd.quantity->>'confidence')::numeric) >= {threshold}\n        AND MIN((ivd.unit_price->>'confidence')::numeric) >= {threshold}\n)\nSELECT\n    d.batch_name,\n    d.accuracy,\n    (i.invoice_number->>'value')::text AS invoice_number,\n    (i.invoice_number->>'confidence')::numeric AS inv_num_conf,\n    (i.invoice_date->>'value')::text AS invoice_date,\n    (i.invoice_date->>'confidence')::numeric AS inv_date_conf,\n    (i.due_date->>'value')::text AS due_date,\n    (i.due_date->>'confidence')::numeric AS due_date_conf,\n    v.name AS vendor_name,\n    idc.line_count,\n    idc.min_desc_conf,\n    idc.min_qty_conf,\n    idc.min_price_conf,\n    LEAST(\n        (i.invoice_number->>'confidence')::numeric,\n        (i.invoice_date->>'confidence')::numeric,\n        (i.due_date->>'confidence')::numeric,\n        idc.min_desc_conf,\n        idc.min_qty_conf,\n        idc.min_price_conf\n    ) AS overall_min_confidence,\n    d.status\nFROM icap_invoice i\nLEFT JOIN icap_vendor v ON i.vendor_id = v.id\nINNER JOIN icap_document d ON i.document_id = d.id\nINNER JOIN invoice_detail_confidence idc ON i.document_id = idc.document_id\nWHERE d.status = 2 AND d.sub_status = 15\n  AND (i.invoice_number->>'confidence')::numeric >= {threshold}\n  AND (i.invoice_date->>'confidence')::numeric >= {threshold}\n  AND (i.due_date->>'confidence')::numeric >= {threshold}\nORDER BY overall_min_confidence DESC;"
                },
                "execution_plan": {
                    "step_1": "Extract threshold from user query (default: 95.0)",
                    "step_2": "Use CTE to aggregate line item confidence scores (MIN across ALL line items)",
                    "step_3": "Join invoice header with aggregated line item confidence",
                    "step_4": "Filter: status='2' AND sub_status='15' (icap_document) AND all 6 fields (3 header + 3 detail) >= threshold",
                    "step_5": "SKIP vendor_id validation (it's UUID, no confidence attribute)",
                    "step_6": "For EACH qualifying invoice: UPDATE using subquery for status ID lookup",
                    "step_7": "Execute postgres_write with dry_run=True first using the write_query_template",
                    "step_8": "If OK, execute postgres_write with dry_run=False",
                    "step_9": "Report: invoice_number, vendor, line_count, confidence scores, status",
                    "step_10": "Return formatted table with approved invoices"
                },
                "write_query_template": "UPDATE icap_document SET status = (SELECT status FROM icap_workflow_status WHERE status_code = 'Bill_Export_In_Progress' LIMIT 1 ), modified_on = NOW() WHERE batch_name = '{batch_name}';",
                "schema_context": "**Critical Fields Validation:**\n\n**icap_invoice (Header - 3 JSONB fields):**\n- invoice_number (JSONB) - has confidence\n- invoice_date (JSONB) - has confidence\n- due_date (JSONB) - has confidence\n- vendor_id (UUID) - NO confidence attribute, skip validation\n\n**icap_invoice_detail (Line Items - 3 JSONB fields):**\n- description (JSONB) - has confidence\n- quantity (JSONB) - has confidence\n- unit_price (JSONB) - has confidence\n\n**Validation Logic:**\n- Check ALL 6 JSONB fields >= threshold\n- Use MIN() across all line items (strictest validation)\n- INNER JOIN ensures invoices have line items\n- status ENUM (icap_document): '0'=New, '2'=Needs Review, '3'=Approved\n\n**JSONB Structure:** {\"value\": \"data\", \"confidence\": 98.5, \"pageNo\": 1}",
                "generated_at": "2026-01-05T12:35:00.000000",
                "configuration": {
                    "trigger_type": "text_query",
                    "output_format": "text",
                    "prompt": "AI-driven invoice auto-approval. Validates 6 critical fields (invoice_number, invoice_date, due_date, description, quantity, unit_price). Updates status for 'In Progress' documents (status=2, sub_status=15) with high confidence."
                }
            }
        },
        "use_cases": [
            "Auto-approve high-confidence invoices with line items",
            "Validate OCR accuracy across header and details",
            "Fast-track complete invoices to payment"
        ]
    },
    {
        "id": "vendor-gl-breakdown",
        "name": "Vendor GL Breakdown Report",
        "description": "Generate GL breakdown reports for invoices from specific vendors with category mappings",
        "category": "Finance & Accounting",
        "icon": "FileText",
        "template": {
            "prompt": "You are a GL reporting specialist. Generate comprehensive GL breakdown reports for invoices from specific vendors. Include invoice details, line item descriptions, quantities, amounts, and GL category mappings for each line item. Use postgres_inspect_schema first to understand the schema structure and relationships.",
            "trigger_type": "conditions",
            "input_fields": [
                {
                    "name": "vendor_name",
                    "type": "text",
                    "label": "Vendor Name",
                    "description": "Enter the vendor name for the GL breakdown report"
                }
            ],
            "output_format": "text",
            "tools": [
                "postgres_query",
                "postgres_inspect_schema"
            ],
            "default_visualization_preferences": "pie chart showing GL category distribution, bar chart comparing line totals by category",
            "execution_guidance": {
                "query_template": {
                    "base_query": "SELECT\n    d.batch_name AS batch_name,\n    (i.invoice_number->>'value')::text AS invoice_number,\n    (i.invoice_date->>'value')::text AS invoice_date,\n    NULLIF(i.total->>'value', '')::numeric AS invoice_total,\n    (i.sub_total->>'value')::text AS subtotal,\n    (i.tax->>'value')::text AS tax,\n    v.name AS vendor_name,\n    v.company AS vendor_company,\n    (ivd.description->>'value')::text AS line_item_description,\n    (ivd.item_code->>'value')::text AS item_code,\n    (ivd.quantity->>'value')::text AS quantity,\n    (ivd.unit_price->>'value')::text AS unit_price,\n    NULLIF(ivd.total_price->>'value', '')::numeric AS line_total,\n    pm.name AS product_name,\n    pm.product_code AS product_code,\n    tcm.name AS category_name,\n    g.name AS gl_name,\n    g.code AS gl_code,\n    g.account_type AS gl_account_type\nFROM icap_invoice i\nLEFT JOIN icap_vendor v ON i.vendor_id = v.id\nINNER JOIN icap_document d ON i.document_id = d.id\nLEFT JOIN icap_invoice_detail ivd ON ivd.document_id = i.document_id\nLEFT JOIN icap_product_master pm ON pm.vendor_id = v.id\nLEFT JOIN icap_product_category_mapping pcm ON pm.id = pcm.product_id\nLEFT JOIN icap_tenant_category_master tcm ON pcm.gl_category_id = tcm.id\nLEFT JOIN icap_tenant_gl_category_mapping tgcm ON tcm.id = tgcm.category_id\nLEFT JOIN icap_gl g ON tgcm.gl_id = g.id\nWHERE v.name ILIKE '%{vendor_name}%'\nORDER BY i.invoice_number->>'value', ivd.id;",
                    "parameters": [
                        "vendor_name"
                    ],
                    "param_instructions": "Extract 'vendor_name' from user query. Use partial matching with ILIKE for flexibility.",
                    "description": "Complete GL breakdown with invoice header, line items, GL categories, and product mappings for specified vendor.",
                    "where_clause": "WHERE v.name ILIKE '%{vendor_name}%'",
                    "full_template": "SELECT\n    d.batch_name AS batch_name,\n    (i.invoice_number->>'value')::text AS invoice_number,\n    (i.invoice_date->>'value')::text AS invoice_date,\n    NULLIF(i.total->>'value', '')::numeric AS invoice_total,\n    (i.sub_total->>'value')::text AS subtotal,\n    (i.tax->>'value')::text AS tax,\n    v.name AS vendor_name,\n    v.company AS vendor_company,\n    (ivd.description->>'value')::text AS line_item_description,\n    (ivd.item_code->>'value')::text AS item_code,\n    (ivd.quantity->>'value')::text AS quantity,\n    (ivd.unit_price->>'value')::text AS unit_price,\n    NULLIF(ivd.total_price->>'value', '')::numeric AS line_total,\n    pm.name AS product_name,\n    pm.product_code AS product_code,\n    tcm.name AS category_name,\n    g.name AS gl_name,\n    g.code AS gl_code,\n    g.account_type AS gl_account_type\nFROM icap_invoice i\nLEFT JOIN icap_vendor v ON i.vendor_id = v.id\nINNER JOIN icap_document d ON i.document_id = d.id\nLEFT JOIN icap_invoice_detail ivd ON ivd.document_id = i.document_id\nLEFT JOIN icap_product_master pm ON pm.vendor_id = v.id\nLEFT JOIN icap_product_category_mapping pcm ON pm.id = pcm.product_id\nLEFT JOIN icap_tenant_category_master tcm ON pcm.gl_category_id = tcm.id\nLEFT JOIN icap_tenant_gl_category_mapping tgcm ON tcm.id = tgcm.category_id\nLEFT JOIN icap_gl g ON tgcm.gl_id = g.id\nWHERE v.name ILIKE '%{vendor_name}%'\nORDER BY i.invoice_number->>'value', ivd.id;"
                },
                "execution_plan": {
                    "step_1": "Load pre-built query template from execution_guidance",
                    "step_2": "Extract 'vendor_name' from user query. Use partial matching with ILIKE for flexibility.",
                    "step_3": "Replace template parameters: {vendor_name}",
                    "step_4": "Execute filled query using postgres_query tool",
                    "step_5": "Structure results as table_data with columns and rows arrays",
                    "step_6": "Include row_count and column metadata",
                    "step_7": "Return formatted table for interactive display"
                },
                "schema_context": "The database has been pre-inspected for your task. Key tables and columns:\n\n**Table: icap_invoice**\n- Columns (22): id, document_id, vendor_id, other_charges, credit_and_returns, invoice_number, invoice_date, due_date, tax, freight_charges, discount, total, sub_total, street, zip, city, country, state, payment_date, balance_amount, created_at, updated_at\n- JSONB columns (require ->> operator): other_charges, credit_and_returns, invoice_number, invoice_date, due_date, tax, freight_charges, discount, total, sub_total, street, zip, city, country, state, payment_date, balance_amount\n- Joins with: document_id \u2192 icap_document, vendor_id \u2192 icap_vendor\n- Related detail tables: icap_invoice_detail\n\n**Table: icap_invoice_detail**\n- Columns (13): id, document_id, uom, pack, size_numeric, size_unit, item_code, description, quantity, unit_price, total_price, category_id, product_id\n- JSONB columns (require ->> operator): uom, pack, size_numeric, size_unit, item_code, description, quantity, unit_price, total_price, category_id, product_id\n- Joins with: document_id \u2192 icap_document\n\n**Table: icap_vendor**\n- Columns (11): id, tenant_id, name, company, address, email, active, created_by, modified_by, created_on, modified_on\n- Related detail tables: icap_invoice, icap_product_master\n\n**Table: icap_product_master**\n- Columns (8): id, product_code, name, created_on, tenant_id, product_code_id, vendor_id, external_product_id\n- Joins with: vendor_id \u2192 icap_vendor\n\n\u26a0\ufe0f IMPORTANT: This is just a preview. You must still call postgres_inspect_schema() for each table before writing queries to get complete column lists and relationships.",
                "generated_at": "2026-01-02T18:48:34.480921",
                "configuration": {
                    "trigger_type": "text_query",
                    "output_format": "text",
                    "prompt": "You are a GL reporting specialist. Generate comprehensive GL breakdown reports for invoices from specific vendors. Include invoice details, line item descriptions, quantities, amounts, and GL category mappings for each line item. Use postgres_inspect_schema first to understand the schema structure and relationships."
                }
            }
        },
        "use_cases": [
            "GL account reconciliation",
            "Vendor-specific expense analysis",
            "Category-based reporting"
        ]
    },
    {
        "id": "invoice-payment-audit",
        "name": "Invoice Payment Status Auditor",
        "description": "Audit invoices within a date range to check for payment status and identify issues",
        "category": "Accounts Payable",
        "icon": "Search",
        "template": {
            "prompt": "You are an invoice audit specialist. Audit all invoices within a specified date range to check payment status, identify unpaid invoices, overdue invoices, and payment delays. Include invoice details, vendor information, due dates, payment dates, and outstanding balances. Use postgres_inspect_schema first to understand the schema.",
            "trigger_type": "date_range",
            "input_fields": [
                {
                    "name": "start_date",
                    "type": "date",
                    "label": "Start Date"
                },
                {
                    "name": "end_date",
                    "type": "date",
                    "label": "End Date"
                }
            ],
            "tools": [
                "postgres_query",
                "postgres_inspect_schema"
            ],
            "default_visualization_preferences": "pie chart showing payment status distribution, bar chart comparing amounts by status",
            "execution_guidance": {
                "query_template": {
                    "base_query": "SELECT d.batch_name, (i.invoice_number->>'value')::text AS invoice_number, (i.due_date->>'value')::text AS due_date, CASE WHEN TO_DATE(NULLIF(i.due_date->>'value', ''), 'MM/DD/YYYY') < CURRENT_DATE AND NULLIF(i.payment_date->>'value', '') IS NULL THEN CURRENT_DATE - TO_DATE(NULLIF(i.due_date->>'value', ''), 'MM/DD/YYYY') ELSE 0 END AS days_overdue, NULLIF(i.total->>'value', '')::numeric AS total_amount, v.name AS vendor_name, CASE WHEN NULLIF(i.payment_date->>'value', '') IS NOT NULL THEN 'Paid' WHEN TO_DATE(NULLIF(i.due_date->>'value', ''), 'MM/DD/YYYY') < CURRENT_DATE THEN 'Overdue' ELSE 'Unpaid' END AS payment_status FROM icap_invoice i LEFT JOIN icap_vendor v ON i.vendor_id = v.id INNER JOIN icap_document d ON i.document_id = d.id WHERE TO_DATE(NULLIF(i.invoice_date->>'value', ''), 'MM/DD/YYYY') BETWEEN TO_DATE('{start_date}', 'MM/DD/YYYY') AND TO_DATE('{end_date}', 'MM/DD/YYYY') ORDER BY days_overdue DESC, total_amount DESC;",
                    "parameters": [
                        "start_date",
                        "end_date"
                    ],
                    "param_instructions": "Extract 'start_date' and 'end_date' from input_fields in MM/DD/YYYY format matching JSONB date format.",
                    "description": "Comprehensive payment audit with status categorization, prioritizing overdue and unpaid invoices first.",
                    "where_clause": "WHERE TO_DATE(i.invoice_date->>'value', 'MM/DD/YYYY') BETWEEN TO_DATE('{start_date}', 'MM/DD/YYYY') AND TO_DATE('{end_date}', 'MM/DD/YYYY')",
                    "full_template": "SELECT d.batch_name, (i.invoice_number->>'value')::text AS invoice_number, (i.due_date->>'value')::text AS due_date, CASE WHEN TO_DATE(NULLIF(i.due_date->>'value', ''), 'MM/DD/YYYY') < CURRENT_DATE AND NULLIF(i.payment_date->>'value', '') IS NULL THEN CURRENT_DATE - TO_DATE(NULLIF(i.due_date->>'value', ''), 'MM/DD/YYYY') ELSE 0 END AS days_overdue, NULLIF(i.total->>'value', '')::numeric AS total_amount, v.name AS vendor_name, CASE WHEN NULLIF(i.payment_date->>'value', '') IS NOT NULL THEN 'Paid' WHEN TO_DATE(NULLIF(i.due_date->>'value', ''), 'MM/DD/YYYY') < CURRENT_DATE THEN 'Overdue' ELSE 'Unpaid' END AS payment_status FROM icap_invoice i LEFT JOIN icap_vendor v ON i.vendor_id = v.id INNER JOIN icap_document d ON i.document_id = d.id WHERE TO_DATE(NULLIF(i.invoice_date->>'value', ''), 'MM/DD/YYYY') BETWEEN TO_DATE('{start_date}', 'MM/DD/YYYY') AND TO_DATE('{end_date}', 'MM/DD/YYYY') ORDER BY days_overdue DESC, total_amount DESC;"
                },
                "execution_plan": {
                    "step_1": "Load pre-built query template from execution_guidance",
                    "step_2": "Extract 'start_date' and 'end_date' from input_fields in MM/DD/YYYY format matching JSONB date format.",
                    "step_3": "Replace template parameters: {start_date}, {end_date}",
                    "step_4": "Execute filled query using postgres_query tool",
                    "step_5": "Structure results as table_data with columns and rows arrays",
                    "step_6": "Include row_count and column metadata",
                    "step_7": "Return formatted table for interactive display"
                },
                "schema_context": "The database has been pre-inspected for your task. Key tables and columns:\n\n**Table: icap_invoice**\n- Columns (22): id, document_id, vendor_id, other_charges, credit_and_returns, invoice_number, invoice_date, due_date, tax, freight_charges, discount, total, sub_total, street, zip, city, country, state, payment_date, balance_amount, created_at, updated_at\n- JSONB columns (require ->> operator): other_charges, credit_and_returns, invoice_number, invoice_date, due_date, tax, freight_charges, discount, total, sub_total, street, zip, city, country, state, payment_date, balance_amount\n- Joins with: document_id \u2192 icap_document, vendor_id \u2192 icap_vendor\n- Related detail tables: icap_invoice_detail\n\n**Table: icap_invoice_detail**\n- Columns (13): id, document_id, uom, pack, size_numeric, size_unit, item_code, description, quantity, unit_price, total_price, category_id, product_id\n- JSONB columns (require ->> operator): uom, pack, size_numeric, size_unit, item_code, description, quantity, unit_price, total_price, category_id, product_id\n- Joins with: document_id \u2192 icap_document\n\n**Table: icap_vendor**\n- Columns (11): id, tenant_id, name, company, address, email, active, created_by, modified_by, created_on, modified_on\n- Related detail tables: icap_invoice, icap_product_master\n\n**Table: icap_product_master**\n- Columns (8): id, product_code, name, created_on, tenant_id, product_code_id, vendor_id, external_product_id\n- Joins with: vendor_id \u2192 icap_vendor\n\n\u26a0\ufe0f IMPORTANT: This is just a preview. You must still call postgres_inspect_schema() for each table before writing queries to get complete column lists and relationships.",
                "generated_at": "2026-01-02T18:48:34.480936",
                "configuration": {
                    "trigger_type": "date_range",
                    "output_format": "text",
                    "prompt": "You are an invoice audit specialist. Audit all invoices within a specified date range to check payment status, identify unpaid invoices, overdue invoices, and payment delays. Include invoice details, vendor information, due dates, payment dates, and outstanding balances. Use postgres_inspect_schema first to understand the schema."
                }
            }
        },
        "use_cases": [
            "Payment compliance audit",
            "Identify payment delays",
            "Manage payables effectively"
        ]
    },
    {
        "id": "invoice-missing-data-detector",
        "name": "Invoice Missing Data Detector",
        "description": "Detects invoices missing critical details and flags them for review (status='2')",
        "category": "Data Quality",
        "icon": "AlertTriangle",
        "template": {
            "prompt": "You are a data quality specialist. Scan all invoices to detect missing critical details: invoice number, invoice date, due date, total amount, or missing line items (must have at least one). For invoices with issues, update icap_document.status to '2' (Needs Review). Use postgres_inspect_schema first, then identify issues, update status using postgres_write.",
            "trigger_type": "text_query",
            "input_fields": [],
            "tools": [
                "postgres_query",
                "postgres_inspect_schema",
                "postgres_write"
            ],
            "default_visualization_preferences": "bar chart showing data issue types distribution, pie chart by issue type",
            "execution_guidance": {
                "query_template": {
                    "base_query": "SELECT d.batch_name, (i.invoice_number->>'value')::text AS invoice_number, (i.invoice_date->>'value')::text AS invoice_date, (i.due_date->>'value')::text AS due_date, NULLIF(i.total->>'value', '')::numeric AS total_amount, (SELECT COUNT(*) FROM icap_invoice_detail ivd WHERE ivd.document_id = i.document_id) AS line_item_count, CASE WHEN NULLIF(i.invoice_number->>'value', '') IS NULL THEN 'Missing Invoice Number' WHEN NULLIF(i.invoice_date->>'value', '') IS NULL THEN 'Missing Invoice Date' WHEN NULLIF(i.due_date->>'value', '') IS NULL THEN 'Missing Due Date' WHEN NULLIF(i.total->>'value', '') IS NULL THEN 'Missing Total Amount' WHEN (SELECT COUNT(*) FROM icap_invoice_detail ivd WHERE ivd.document_id = i.document_id) = 0 THEN 'Missing Line Items' ELSE 'Incomplete Data' END AS data_issue FROM icap_invoice i INNER JOIN icap_document d ON i.document_id = d.id WHERE NULLIF(i.invoice_number->>'value', '') IS NULL OR NULLIF(i.invoice_date->>'value', '') IS NULL OR NULLIF(i.due_date->>'value', '') IS NULL OR NULLIF(i.total->>'value', '') IS NULL OR (SELECT COUNT(*) FROM icap_invoice_detail ivd WHERE ivd.document_id = i.document_id) = 0 ORDER BY data_issue, d.batch_name;",
                    "parameters": [],
                    "param_instructions": "No parameters required - scans all invoices for data quality issues.",
                    "description": "Detects invoices with missing critical fields (number, date, due date, total) or no line items.",
                    "where_clause": "WHERE NULLIF(i.invoice_number->>'value', '') IS NULL OR NULLIF(i.invoice_date->>'value', '') IS NULL OR NULLIF(i.due_date->>'value', '') IS NULL OR NULLIF(i.total->>'value', '') IS NULL OR (SELECT COUNT(*) FROM icap_invoice_detail ivd WHERE ivd.document_id = i.document_id) = 0",
                    "full_template": "SELECT d.batch_name, (i.invoice_number->>'value')::text AS invoice_number, (i.invoice_date->>'value')::text AS invoice_date, (i.due_date->>'value')::text AS due_date, NULLIF(i.total->>'value', '')::numeric AS total_amount, (SELECT COUNT(*) FROM icap_invoice_detail ivd WHERE ivd.document_id = i.document_id) AS line_item_count, CASE WHEN NULLIF(i.invoice_number->>'value', '') IS NULL THEN 'Missing Invoice Number' WHEN NULLIF(i.invoice_date->>'value', '') IS NULL THEN 'Missing Invoice Date' WHEN NULLIF(i.due_date->>'value', '') IS NULL THEN 'Missing Due Date' WHEN NULLIF(i.total->>'value', '') IS NULL THEN 'Missing Total Amount' WHEN (SELECT COUNT(*) FROM icap_invoice_detail ivd WHERE ivd.document_id = i.document_id) = 0 THEN 'Missing Line Items' ELSE 'Incomplete Data' END AS data_issue FROM icap_invoice i INNER JOIN icap_document d ON i.document_id = d.id WHERE NULLIF(i.invoice_number->>'value', '') IS NULL OR NULLIF(i.invoice_date->>'value', '') IS NULL OR NULLIF(i.due_date->>'value', '') IS NULL OR NULLIF(i.total->>'value', '') IS NULL OR (SELECT COUNT(*) FROM icap_invoice_detail ivd WHERE ivd.document_id = i.document_id) = 0 ORDER BY data_issue, d.batch_name;"
                },
                "execution_plan": {
                    "step_1": "Load pre-built query template from execution_guidance",
                    "step_2": "No parameters required",
                    "step_3": "Execute query directly using postgres_query tool to find invoices with missing data",
                    "step_4": "For EACH invoice found with missing data, prepare UPDATE query using the write_query_template",
                    "step_5": "Execute postgres_write with dry_run=True first to preview status updates",
                    "step_6": "If preview looks good, execute postgres_write with dry_run=False to flag invoices with status='2' (Needs Review)",
                    "step_7": "Structure results showing flagged invoices with missing data type",
                    "step_8": "Include row_count and affected_rows metadata",
                    "step_9": "Return formatted table with flagged invoices"
                },
                "write_query_template": "UPDATE icap_document SET status = 2 WHERE batch_name = '{batch_name}';",
                "schema_context": "The database has been pre-inspected for your task. Key tables and columns:\n\n**Table: icap_invoice**\n- Columns: id, document_id, invoice_number, invoice_date, due_date, total, ...\n- JSONB columns: invoice_number, invoice_date, due_date, total\n- Joins with: document_id \u2192 icap_document\n\n**Table: icap_invoice_detail**\n- Columns: id, document_id, ...\n- Joins with: document_id \u2192 icap_document\n\n**Table: icap_document**\n- Columns: id, batch_name, status\n\n\u26a0\ufe0f IMPORTANT: This is just a preview. You must still call postgres_inspect_schema() for each table before writing queries to get complete column lists and relationships.",
                "generated_at": "2026-01-20T11:45:00.000000",
                "configuration": {
                    "trigger_type": "text_query",
                    "output_format": "text",
                    "prompt": "You are a data quality specialist. Scan all invoices to detect missing critical details: invoice number, invoice date, due date, total amount, or missing line items. Generate a report listing problematic invoices."
                }
            }
        },
        "use_cases": [
            "Data cleanup campaigns",
            "Vendor communication for missing info",
            "Improve invoice data quality",
            "Automated follow-up workflows",
            "Proactive data quality management"
        ]
    },
    {
        "id": "monthly-expense-report",
        "name": "Monthly Expense Report",
        "description": "Generate comprehensive monthly expense reports with totals, breakdowns by category, and vendor analysis",
        "category": "Finance & Accounting",
        "icon": "BarChart3",
        "template": {
            "prompt": "You are a financial reporting specialist. Generate a detailed monthly expense report showing total expenses, breakdown by vendor, line item details with product descriptions, quantities, amounts, and GL categories for the specified month and year. Use postgres_inspect_schema first.",
            "trigger_type": "date_range",
            "input_fields": [
                {
                    "name": "start_date",
                    "type": "date",
                    "label": "Start Date"
                },
                {
                    "name": "end_date",
                    "type": "date",
                    "label": "End Date"
                }
            ],
            "tools": [
                "postgres_query",
                "postgres_inspect_schema"
            ],
            "default_visualization_preferences": "bar chart showing monthly expenses by vendor, pie chart showing category distribution, line chart showing expense trends",
            "execution_guidance": {
                "query_template": {
                    "base_query": "SELECT\n    d.batch_name AS batch_name,\n    (i.invoice_number->>'value')::text AS invoice_number,\n    (i.invoice_date->>'value')::text AS invoice_date,\n    (i.due_date->>'value')::text AS due_date,\n    NULLIF(i.total->>'value', '')::numeric AS invoice_total,\n    (i.sub_total->>'value')::text AS subtotal,\n    (i.tax->>'value')::text AS tax,\n    (i.payment_date->>'value')::text AS payment_date,\n    v.name AS vendor_name,\n    v.company AS vendor_company,\n    (ivd.description->>'value')::text AS product_description,\n    (ivd.item_code->>'value')::text AS item_code,\n    (ivd.quantity->>'value')::text AS quantity,\n    (ivd.unit_price->>'value')::text AS unit_price,\n    NULLIF(ivd.total_price->>'value', '')::numeric AS line_total,\n    tcm.name AS category_name,\n    g.name AS gl_name,\n    g.code AS gl_code\nFROM icap_invoice i\nLEFT JOIN icap_vendor v ON i.vendor_id = v.id\nINNER JOIN icap_document d ON i.document_id = d.id\nLEFT JOIN icap_invoice_detail ivd ON ivd.document_id = i.document_id\nLEFT JOIN icap_product_master pm ON NULLIF(ivd.product_id->>'value', '') IS NOT NULL AND (ivd.product_id->>'value')::uuid = pm.id\nLEFT JOIN icap_product_category_mapping pcm ON pm.id = pcm.product_id\nLEFT JOIN icap_tenant_category_master tcm ON pcm.gl_category_id = tcm.id\nLEFT JOIN icap_tenant_gl_category_mapping tgcm ON tcm.id = tgcm.category_id\nLEFT JOIN icap_gl g ON tgcm.gl_id = g.id\nWHERE TO_DATE(NULLIF(i.invoice_date->>'value', ''), 'MM/DD/YYYY') BETWEEN TO_DATE('{start_date}', 'MM/DD/YYYY') AND TO_DATE('{end_date}', 'MM/DD/YYYY')\nORDER BY i.invoice_number->>'value', ivd.id;",
                    "parameters": [
                        "start_date",
                        "end_date"
                    ],
                    "param_instructions": "Extract 'month' (2-digit format 01-12) and 'year' (4-digit) from input_fields.",
                    "description": "Complete monthly expense report with invoice headers, line item breakdowns, vendor info, and GL categories.",
                    "where_clause": "WHERE TO_DATE(NULLIF(i.invoice_date->>'value', ''), 'MM/DD/YYYY') BETWEEN TO_DATE('{start_date}', 'MM/DD/YYYY') AND TO_DATE('{end_date}', 'MM/DD/YYYY')",
                    "full_template": "SELECT\n    d.batch_name AS batch_name,\n    (i.invoice_number->>'value')::text AS invoice_number,\n    (i.invoice_date->>'value')::text AS invoice_date,\n    (i.due_date->>'value')::text AS due_date,\n    NULLIF(i.total->>'value', '')::numeric AS invoice_total,\n    (i.sub_total->>'value')::text AS subtotal,\n    (i.tax->>'value')::text AS tax,\n    (i.payment_date->>'value')::text AS payment_date,\n    v.name AS vendor_name,\n    v.company AS vendor_company,\n    (ivd.description->>'value')::text AS product_description,\n    (ivd.item_code->>'value')::text AS item_code,\n    (ivd.quantity->>'value')::text AS quantity,\n    (ivd.unit_price->>'value')::text AS unit_price,\n    NULLIF(ivd.total_price->>'value', '')::numeric AS line_total,\n    tcm.name AS category_name,\n    g.name AS gl_name,\n    g.code AS gl_code\nFROM icap_invoice i\nLEFT JOIN icap_vendor v ON i.vendor_id = v.id\nINNER JOIN icap_document d ON i.document_id = d.id\nLEFT JOIN icap_invoice_detail ivd ON ivd.document_id = i.document_id\nLEFT JOIN icap_product_master pm ON NULLIF(ivd.product_id->>'value', '') IS NOT NULL AND (ivd.product_id->>'value')::uuid = pm.id\nLEFT JOIN icap_product_category_mapping pcm ON pm.id = pcm.product_id\nLEFT JOIN icap_tenant_category_master tcm ON pcm.gl_category_id = tcm.id\nLEFT JOIN icap_tenant_gl_category_mapping tgcm ON tcm.id = tgcm.category_id\nLEFT JOIN icap_gl g ON tgcm.gl_id = g.id\nWHERE TO_DATE(NULLIF(i.invoice_date->>'value', ''), 'MM/DD/YYYY') BETWEEN TO_DATE('{start_date}', 'MM/DD/YYYY') AND TO_DATE('{end_date}', 'MM/DD/YYYY')\nORDER BY i.invoice_number->>'value', ivd.id;"
                },
                "execution_plan": {
                    "step_1": "Load pre-built query template from execution_guidance",
                    "step_2": "Extract 'month' (2-digit format 01-12) and 'year' (4-digit) from input_fields.",
                    "step_3": "Replace template parameters: {month}, {year}",
                    "step_4": "Execute filled query using postgres_query tool",
                    "step_5": "Structure results as table_data with columns and rows arrays",
                    "step_6": "Include row_count and column metadata",
                    "step_7": "Return formatted table for interactive display"
                },
                "schema_context": "The database has been pre-inspected for your task. Key tables and columns:\n\n**Table: icap_invoice**\n- Columns (22): id, document_id, vendor_id, other_charges, credit_and_returns, invoice_number, invoice_date, due_date, tax, freight_charges, discount, total, sub_total, street, zip, city, country, state, payment_date, balance_amount, created_at, updated_at\n- JSONB columns (require ->> operator): other_charges, credit_and_returns, invoice_number, invoice_date, due_date, tax, freight_charges, discount, total, sub_total, street, zip, city, country, state, payment_date, balance_amount\n- Joins with: document_id \u2192 icap_document, vendor_id \u2192 icap_vendor\n- Related detail tables: icap_invoice_detail\n\n**Table: icap_invoice_detail**\n- Columns (13): id, document_id, uom, pack, size_numeric, size_unit, item_code, description, quantity, unit_price, total_price, category_id, product_id\n- JSONB columns (require ->> operator): uom, pack, size_numeric, size_unit, item_code, description, quantity, unit_price, total_price, category_id, product_id\n- Joins with: document_id \u2192 icap_document\n\n**Table: icap_vendor**\n- Columns (11): id, tenant_id, name, company, address, email, active, created_by, modified_by, created_on, modified_on\n- Related detail tables: icap_invoice, icap_product_master\n\n**Table: icap_product_master**\n- Columns (8): id, product_code, name, created_on, tenant_id, product_code_id, vendor_id, external_product_id\n- Joins with: vendor_id \u2192 icap_vendor\n\n\u26a0\ufe0f IMPORTANT: This is just a preview. You must still call postgres_inspect_schema() for each table before writing queries to get complete column lists and relationships.",
                "generated_at": "2026-01-02T18:48:34.480968",
                "configuration": {
                    "trigger_type": "date_range",
                    "output_format": "text",
                    "prompt": "You are a financial reporting specialist. Generate a detailed monthly expense report showing total expenses, breakdown by vendor, line item details with product descriptions, quantities, amounts, and GL categories for the specified month and year. Use postgres_inspect_schema first."
                }
            }
        },
        "use_cases": [
            "Monthly financial reporting",
            "Budget tracking",
            "Expense analysis"
        ]
    },
    {
        "id": "vendor-spend-analyzer",
        "name": "Vendor Spend Analyzer",
        "description": "Analyze spending patterns across vendors to identify top suppliers and optimize procurement",
        "category": "Procurement",
        "icon": "DollarSign",
        "template": {
            "prompt": "You are a procurement analyst. Analyze vendor spending patterns by calculating total spend per vendor, number of invoices, average invoice amount, payment status distribution, and identify top vendors with detailed product breakdowns. Use postgres_inspect_schema first.",
            "trigger_type": "date_range",
            "input_fields": [
                {
                    "name": "start_date",
                    "type": "date",
                    "label": "Start Date"
                },
                {
                    "name": "end_date",
                    "type": "date",
                    "label": "End Date"
                }
            ],
            "tools": [
                "postgres_query",
                "postgres_inspect_schema"
            ],
            "default_visualization_preferences": "pie chart showing spend distribution by vendor, bar chart comparing total spend and invoice counts, line chart showing spending trends over time",
            "execution_guidance": {
                "query_template": {
                    "base_query": "WITH vendor_summary AS (\n    SELECT\n        v.name AS vendor_name,\n        v.company AS vendor_company,\n        v.address AS vendor_address,\n        COUNT(DISTINCT i.id) AS invoice_count,\n        SUM(CASE WHEN (i.total->>'value') != '' THEN (i.total->>'value')::numeric ELSE 0 END) AS total_spend,\n        AVG(CASE WHEN (i.total->>'value') != '' THEN (i.total->>'value')::numeric ELSE 0 END) AS avg_invoice_amount,\n        SUM(CASE WHEN i.payment_date->>'value' IS NOT NULL AND i.payment_date->>'value' != '' THEN 1 ELSE 0 END) AS paid_count,\n        SUM(CASE WHEN i.payment_date->>'value' IS NULL OR i.payment_date->>'value' = '' THEN 1 ELSE 0 END) AS unpaid_count\n    FROM icap_invoice i\n    LEFT JOIN icap_vendor v ON i.vendor_id = v.id\n    WHERE TO_DATE(i.invoice_date->>'value', 'MM/DD/YYYY') BETWEEN TO_DATE('{start_date}', 'MM/DD/YYYY') AND TO_DATE('{end_date}', 'MM/DD/YYYY')\n    AND (i.total->>'value') IS NOT NULL\n    GROUP BY v.name, v.company, v.address\n)\nSELECT \n    vendor_name,\n    vendor_company,\n    \n    invoice_count,\n    total_spend,\n    ROUND(avg_invoice_amount, 2) AS avg_invoice_amount,\n    paid_count,\n    unpaid_count,\n    ROUND((total_spend / NULLIF((SELECT SUM(total_spend) FROM vendor_summary), 0)) * 100, 2) AS spend_percentage\nFROM vendor_summary\nORDER BY total_spend DESC;",
                    "parameters": [
                        "start_date",
                        "end_date"
                    ],
                    "param_instructions": "Extract 'start_date' and 'end_date' from input_fields in MM/DD/YYYY format.",
                    "description": "Comprehensive vendor spend analysis with totals, averages, payment distribution, and spend percentage ranking.",
                    "where_clause": "WHERE TO_DATE(i.invoice_date->>'value', 'MM/DD/YYYY') BETWEEN TO_DATE('{start_date}', 'MM/DD/YYYY') AND TO_DATE('{end_date}', 'MM/DD/YYYY')\n    GROUP BY v.name, v.company, v.address\n)\nSELECT \n    vendor_name,\n    vendor_company,\n    \n    invoice_count,\n    total_spend,\n    ROUND(avg_invoice_amount, 2) AS avg_invoice_amount,\n    paid_count,\n    unpaid_count,\n    ROUND((total_spend / NULLIF((SELECT SUM(total_spend) FROM vendor_summary), 0)) * 100, 2) AS spend_percentage\nFROM vendor_summary",
                    "full_template": "WITH vendor_summary AS (\n    SELECT\n        v.name AS vendor_name,\n        v.company AS vendor_company,\n        v.address AS vendor_address,\n        COUNT(DISTINCT i.id) AS invoice_count,\n        SUM(CASE WHEN (i.total->>'value') != '' THEN (i.total->>'value')::numeric ELSE 0 END) AS total_spend,\n        AVG(CASE WHEN (i.total->>'value') != '' THEN (i.total->>'value')::numeric ELSE 0 END) AS avg_invoice_amount,\n        SUM(CASE WHEN i.payment_date->>'value' IS NOT NULL AND i.payment_date->>'value' != '' THEN 1 ELSE 0 END) AS paid_count,\n        SUM(CASE WHEN i.payment_date->>'value' IS NULL OR i.payment_date->>'value' = '' THEN 1 ELSE 0 END) AS unpaid_count\n    FROM icap_invoice i\n    LEFT JOIN icap_vendor v ON i.vendor_id = v.id\n    WHERE TO_DATE(i.invoice_date->>'value', 'MM/DD/YYYY') BETWEEN TO_DATE('{start_date}', 'MM/DD/YYYY') AND TO_DATE('{end_date}', 'MM/DD/YYYY')\n    AND (i.total->>'value') IS NOT NULL\n    GROUP BY v.name, v.company, v.address\n)\nSELECT \n    vendor_name,\n    vendor_company,\n    \n    invoice_count,\n    total_spend,\n    ROUND(avg_invoice_amount, 2) AS avg_invoice_amount,\n    paid_count,\n    unpaid_count,\n    ROUND((total_spend / NULLIF((SELECT SUM(total_spend) FROM vendor_summary), 0)) * 100, 2) AS spend_percentage\nFROM vendor_summary\nORDER BY total_spend DESC;"
                },
                "execution_plan": {
                    "step_1": "Load pre-built query template from execution_guidance",
                    "step_2": "Extract 'start_date' and 'end_date' from input_fields in MM/DD/YYYY format.",
                    "step_3": "Replace template parameters: {start_date}, {end_date}",
                    "step_4": "Execute filled query using postgres_query tool",
                    "step_5": "Structure results as table_data with columns and rows arrays",
                    "step_6": "Include row_count and column metadata",
                    "step_7": "Return formatted table for interactive display"
                },
                "schema_context": "The database has been pre-inspected for your task. Key tables and columns:\n\n**Table: icap_invoice**\n- Columns (22): id, document_id, vendor_id, other_charges, credit_and_returns, invoice_number, invoice_date, due_date, tax, freight_charges, discount, total, sub_total, street, zip, city, country, state, payment_date, balance_amount, created_at, updated_at\n- JSONB columns (require ->> operator): other_charges, credit_and_returns, invoice_number, invoice_date, due_date, tax, freight_charges, discount, total, sub_total, street, zip, city, country, state, payment_date, balance_amount\n- Joins with: document_id \u2192 icap_document, vendor_id \u2192 icap_vendor\n- Related detail tables: icap_invoice_detail\n\n**Table: icap_invoice_detail**\n- Columns (13): id, document_id, uom, pack, size_numeric, size_unit, item_code, description, quantity, unit_price, total_price, category_id, product_id\n- JSONB columns (require ->> operator): uom, pack, size_numeric, size_unit, item_code, description, quantity, unit_price, total_price, category_id, product_id\n- Joins with: document_id \u2192 icap_document\n\n**Table: icap_vendor**\n- Columns (11): id, tenant_id, name, company, address, email, active, created_by, modified_by, created_on, modified_on\n- Related detail tables: icap_invoice, icap_product_master\n\n**Table: icap_product_master**\n- Columns (8): id, product_code, name, created_on, tenant_id, product_code_id, vendor_id, external_product_id\n- Joins with: vendor_id \u2192 icap_vendor\n\n\u26a0\ufe0f IMPORTANT: This is just a preview. You must still call postgres_inspect_schema() for each table before writing queries to get complete column lists and relationships.",
                "generated_at": "2026-01-02T18:48:34.480980",
                "configuration": {
                    "trigger_type": "date_range",
                    "output_format": "text",
                    "prompt": "You are a procurement analyst. Analyze vendor spending patterns by calculating total spend per vendor, number of invoices, average invoice amount, payment status distribution, and identify top vendors with detailed product breakdowns. Use postgres_inspect_schema first."
                }
            }
        },
        "use_cases": [
            "Vendor performance review",
            "Negotiate better rates",
            "Consolidate suppliers"
        ]
    },
    {
        "id": "invoice-aging-report",
        "name": "Invoice Aging Report",
        "description": "Track unpaid invoices and identify overdue payments to improve cash flow management",
        "category": "Accounts Payable",
        "icon": "Clock",
        "template": {
            "prompt": "You are an accounts payable specialist. Generate an aging report for unpaid invoices, categorizing them by age buckets (0-30 days, 31-60 days, 61-90 days, 90+ days). Include complete invoice details, vendor information, amounts, and days overdue. Use postgres_inspect_schema first.",
            "trigger_type": "text_query",
            "input_fields": [],
            "tools": [
                "postgres_query",
                "postgres_inspect_schema"
            ],
            "default_visualization_preferences": "bar chart showing aging buckets distribution, pie chart showing amounts by aging bucket, bar chart comparing overdue amounts by vendor",
            "execution_guidance": {
                "query_template": {
                    "base_query": "WITH invoice_data AS (\n    SELECT \n        d.batch_name,\n        (i.invoice_number->>'value')::text AS invoice_number,\n        (i.invoice_date->>'value')::text AS invoice_date,\n        (i.due_date->>'value')::text AS raw_due_date,\n        NULLIF(i.total->>'value', '')::numeric AS total_amount,\n        NULLIF(i.balance_amount->>'value', '')::numeric AS balance_due,\n        v.name AS vendor_name,\n        v.company AS vendor_company,\n        TO_DATE(NULLIF(i.due_date->>'value', ''), 'MM/DD/YYYY') AS parsed_due_date\n    FROM icap_invoice i\n    LEFT JOIN icap_vendor v ON i.vendor_id = v.id\n    INNER JOIN icap_document d ON i.document_id = d.id\n    WHERE (i.payment_date->>'value' IS NULL OR i.payment_date->>'value' = '')\n      AND (i.balance_amount->>'value' IS NULL OR i.balance_amount->>'value' = '' OR NULLIF(i.balance_amount->>'value', '')::numeric > 0)\n      AND (i.due_date->>'value' IS NOT NULL AND i.due_date->>'value' <> '')\n)\nSELECT\n    batch_name,\n    invoice_number,\n    invoice_date,\n    raw_due_date AS due_date,\n    total_amount,\n    balance_due,\n    vendor_name,\n    vendor_company,\n    CASE \n        WHEN parsed_due_date IS NULL THEN 'Invalid Date'\n        WHEN parsed_due_date >= CURRENT_DATE THEN 'Current'\n        WHEN (CURRENT_DATE - parsed_due_date) <= 30 THEN '1-30 Days Overdue'\n        WHEN (CURRENT_DATE - parsed_due_date) <= 60 THEN '31-60 Days Overdue'\n        WHEN (CURRENT_DATE - parsed_due_date) <= 90 THEN '61-90 Days Overdue'\n        ELSE '90+ Days Overdue'\n    END AS aging_bucket,\n    CASE \n        WHEN parsed_due_date IS NOT NULL THEN (CURRENT_DATE - parsed_due_date)\n        ELSE NULL\n    END AS days_overdue\nFROM invoice_data\nORDER BY days_overdue DESC NULLS LAST, total_amount DESC;",
                    "parameters": [],
                    "param_instructions": "No parameters required - analyzes all unpaid invoices with valid due dates.",
                    "description": "Aging report showing unpaid invoices categorized by age buckets (Current, 1-30, 31-60, 61-90, 90+).",
                    "where_clause": "WHERE (i.payment_date->>'value' IS NULL OR i.payment_date->>'value' = '')\n    AND (i.balance_amount->>'value' IS NULL OR i.balance_amount->>'value' = '' OR (i.balance_amount->>'value')::numeric > 0)\n    AND (i.due_date->>'value' IS NOT NULL AND i.due_date->>'value' <> '')",
                    "full_template": "WITH invoice_data AS (\n    SELECT \n        d.batch_name,\n        (i.invoice_number->>'value')::text AS invoice_number,\n        (i.invoice_date->>'value')::text AS invoice_date,\n        (i.due_date->>'value')::text AS raw_due_date,\n        NULLIF(i.total->>'value', '')::numeric AS total_amount,\n        NULLIF(i.balance_amount->>'value', '')::numeric AS total_balance_due,\n        v.name AS vendor_name,\n        v.company AS vendor_company,\n        TO_DATE(NULLIF(i.due_date->>'value', ''), 'MM/DD/YYYY') AS parsed_due_date\n    FROM icap_invoice i\n    LEFT JOIN icap_vendor v ON i.vendor_id = v.id\n    INNER JOIN icap_document d ON i.document_id = d.id\n    WHERE (i.payment_date->>'value' IS NULL OR i.payment_date->>'value' = '')\n      AND (i.balance_amount->>'value' IS NULL OR i.balance_amount->>'value' = '' OR NULLIF(i.balance_amount->>'value', '')::numeric > 0)\n      AND (i.due_date->>'value' IS NOT NULL AND i.due_date->>'value' <> '')\n)\nSELECT\n    batch_name,\n    invoice_number,\n    invoice_date,\n    raw_due_date AS due_date,\n    total_amount,\n    total_balance_due AS balance_due,\n    vendor_name,\n    vendor_company,\n    CASE \n        WHEN parsed_due_date IS NULL THEN 'Invalid Date'\n        WHEN parsed_due_date >= CURRENT_DATE THEN 'Current'\n        WHEN (CURRENT_DATE - parsed_due_date) <= 30 THEN '1-30 Days Overdue'\n        WHEN (CURRENT_DATE - parsed_due_date) <= 60 THEN '31-60 Days Overdue'\n        WHEN (CURRENT_DATE - parsed_due_date) <= 90 THEN '61-90 Days Overdue'\n        ELSE '90+ Days Overdue'\n    END AS aging_bucket,\n    CASE \n        WHEN parsed_due_date IS NOT NULL THEN (CURRENT_DATE - parsed_due_date)\n        ELSE NULL\n    END AS days_overdue\nFROM invoice_data\nORDER BY days_overdue DESC NULLS LAST, total_amount DESC;"
                },
                "execution_plan": {
                    "step_1": "Load pre-built query template from execution_guidance",
                    "step_2": "No parameters required",
                    "step_3": "Execute query directly using postgres_query tool",
                    "step_4": "Structure results as table_data with columns and rows arrays",
                    "step_5": "Include row_count and column metadata",
                    "step_6": "Return formatted table for interactive display"
                },
                "schema_context": "The database has been pre-inspected for your task. Key tables and columns:\n\n**Table: icap_invoice**\n- Columns (22): id, document_id, vendor_id, other_charges, credit_and_returns, invoice_number, invoice_date, due_date, tax, freight_charges, discount, total, sub_total, street, zip, city, country, state, payment_date, balance_amount, created_at, updated_at\n- JSONB columns (require ->> operator): other_charges, credit_and_returns, invoice_number, invoice_date, due_date, tax, freight_charges, discount, total, sub_total, street, zip, city, country, state, payment_date, balance_amount\n- Joins with: document_id \u2192 icap_document, vendor_id \u2192 icap_vendor\n- Related detail tables: icap_invoice_detail\n\n**Table: icap_invoice_detail**\n- Columns (13): id, document_id, uom, pack, size_numeric, size_unit, item_code, description, quantity, unit_price, total_price, category_id, product_id\n- JSONB columns (require ->> operator): uom, pack, size_numeric, size_unit, item_code, description, quantity, unit_price, total_price, category_id, product_id\n- Joins with: document_id \u2192 icap_document\n\n**Table: icap_vendor**\n- Columns (11): id, tenant_id, name, company, address, email, active, created_by, modified_by, created_on, modified_on\n- Related detail tables: icap_invoice, icap_product_master\n\n**Table: icap_product_master**\n- Columns (8): id, product_code, name, created_on, tenant_id, product_code_id, vendor_id, external_product_id\n- Joins with: vendor_id \u2192 icap_vendor\n\n\u26a0\ufe0f IMPORTANT: This is just a preview. You must still call postgres_inspect_schema() for each table before writing queries to get complete column lists and relationships.",
                "generated_at": "2026-01-02T18:48:34.480991",
                "configuration": {
                    "trigger_type": "text_query",
                    "output_format": "text",
                    "prompt": "You are an accounts payable specialist. Generate an aging report for unpaid invoices, categorizing them by age buckets (0-30 days, 31-60 days, 61-90 days, 90+ days). Include complete invoice details, vendor information, amounts, and days overdue. Use postgres_inspect_schema first."
                }
            }
        },
        "use_cases": [
            "Cash flow management",
            "Payment prioritization",
            "Vendor relationship management"
        ]
    },
    {
        "id": "tax-calculation-validator",
        "name": "Tax Calculation Validator",
        "description": "Validate tax calculations on invoices to ensure accuracy and compliance",
        "category": "Finance & Accounting",
        "icon": "Calculator",
        "template": {
            "prompt": "You are a tax validation specialist. Review invoices and verify that tax amounts are correctly calculated based on subtotal. Flag any discrepancies where calculated tax doesn't match reported tax. Include invoice details, vendor info, and variance analysis. Use postgres_inspect_schema first.",
            "trigger_type": "date_range",
            "input_fields": [
                {
                    "name": "start_date",
                    "type": "date",
                    "label": "Start Date"
                },
                {
                    "name": "end_date",
                    "type": "date",
                    "label": "End Date"
                }
            ],
            "tools": [
                "postgres_query",
                "postgres_inspect_schema"
            ],
            "default_visualization_preferences": "pie chart showing validation status distribution, bar chart comparing reported vs calculated tax, scatter plot showing tax variance",
            "execution_guidance": {
                "query_template": {
                    "base_query": "WITH tax_audit AS (SELECT d.batch_name, (i.invoice_number->>'value')::text AS invoice_number, (i.invoice_date->>'value')::text AS invoice_date, v.name AS vendor_name, NULLIF(i.sub_total->>'value', '')::numeric AS subtotal, NULLIF(i.tax->>'value', '')::numeric AS reported_tax, ROUND(COALESCE(NULLIF(i.tax->>'value', '')::numeric, 0) - (COALESCE(NULLIF(i.sub_total->>'value', '')::numeric, 0) * 0.10), 2) AS tax_variance, CASE WHEN NULLIF(i.tax->>'value', '') IS NULL OR NULLIF(i.sub_total->>'value', '') IS NULL THEN 'Missing Data' WHEN ABS(COALESCE(NULLIF(i.tax->>'value', '')::numeric, 0) - (COALESCE(NULLIF(i.sub_total->>'value', '')::numeric, 0) * 0.10)) < 0.01 THEN 'Valid' ELSE 'Variance' END AS validation_status FROM icap_invoice i LEFT JOIN icap_vendor v ON i.vendor_id = v.id INNER JOIN icap_document d ON i.document_id = d.id WHERE TO_DATE(NULLIF(i.invoice_date->>'value', ''), 'MM/DD/YYYY') BETWEEN TO_DATE('{start_date}', 'MM/DD/YYYY') AND TO_DATE('{end_date}', 'MM/DD/YYYY')) SELECT * FROM tax_audit ORDER BY CASE WHEN validation_status = 'Variance' THEN 1 ELSE 2 END, ABS(tax_variance) DESC;",
                    "parameters": [
                        "start_date",
                        "end_date"
                    ],
                    "param_instructions": "Extract 'start_date' and 'end_date' from input_fields. Assumes 10% tax rate (adjust as needed).",
                    "description": "Tax validation showing reported vs calculated tax with variance analysis and validation status.",
                    "where_clause": "WHERE TO_DATE(NULLIF(i.invoice_date->>'value', ''), 'MM/DD/YYYY') BETWEEN TO_DATE('{start_date}', 'MM/DD/YYYY') AND TO_DATE('{end_date}', 'MM/DD/YYYY')",
                    "full_template": "WITH tax_audit AS (SELECT d.batch_name, (i.invoice_number->>'value')::text AS invoice_number, (i.invoice_date->>'value')::text AS invoice_date, v.name AS vendor_name, NULLIF(i.sub_total->>'value', '')::numeric AS subtotal, NULLIF(i.tax->>'value', '')::numeric AS reported_tax, ROUND(COALESCE(NULLIF(i.tax->>'value', '')::numeric, 0) - (COALESCE(NULLIF(i.sub_total->>'value', '')::numeric, 0) * 0.10), 2) AS tax_variance, CASE WHEN NULLIF(i.tax->>'value', '') IS NULL OR NULLIF(i.sub_total->>'value', '') IS NULL THEN 'Missing Data' WHEN ABS(COALESCE(NULLIF(i.tax->>'value', '')::numeric, 0) - (COALESCE(NULLIF(i.sub_total->>'value', '')::numeric, 0) * 0.10)) < 0.01 THEN 'Valid' ELSE 'Variance' END AS validation_status FROM icap_invoice i LEFT JOIN icap_vendor v ON i.vendor_id = v.id INNER JOIN icap_document d ON i.document_id = d.id WHERE TO_DATE(NULLIF(i.invoice_date->>'value', ''), 'MM/DD/YYYY') BETWEEN TO_DATE('{start_date}', 'MM/DD/YYYY') AND TO_DATE('{end_date}', 'MM/DD/YYYY')) SELECT * FROM tax_audit ORDER BY CASE WHEN validation_status = 'Variance' THEN 1 ELSE 2 END, ABS(tax_variance) DESC;"
                },
                "execution_plan": {
                    "step_1": "Load pre-built query template from execution_guidance",
                    "step_2": "Extract 'start_date' and 'end_date' from input_fields. Assumes 10% tax rate (adjust as needed).",
                    "step_3": "Replace template parameters: {start_date}, {end_date}",
                    "step_4": "Execute filled query using postgres_query tool",
                    "step_5": "Structure results as table_data with columns and rows arrays",
                    "step_6": "Include row_count and column metadata",
                    "step_7": "Return formatted table for interactive display"
                },
                "schema_context": "The database has been pre-inspected for your task. Key tables and columns:\n\n**Table: icap_invoice**\n- Columns (22): id, document_id, vendor_id, other_charges, credit_and_returns, invoice_number, invoice_date, due_date, tax, freight_charges, discount, total, sub_total, street, zip, city, country, state, payment_date, balance_amount, created_at, updated_at\n- JSONB columns (require ->> operator): other_charges, credit_and_returns, invoice_number, invoice_date, due_date, tax, freight_charges, discount, total, sub_total, street, zip, city, country, state, payment_date, balance_amount\n- Joins with: document_id \u2192 icap_document, vendor_id \u2192 icap_vendor\n- Related detail tables: icap_invoice_detail\n\n**Table: icap_invoice_detail**\n- Columns (13): id, document_id, uom, pack, size_numeric, size_unit, item_code, description, quantity, unit_price, total_price, category_id, product_id\n- JSONB columns (require ->> operator): uom, pack, size_numeric, size_unit, item_code, description, quantity, unit_price, total_price, category_id, product_id\n- Joins with: document_id \u2192 icap_document\n\n**Table: icap_vendor**\n- Columns (11): id, tenant_id, name, company, address, email, active, created_by, modified_by, created_on, modified_on\n- Related detail tables: icap_invoice, icap_product_master\n\n**Table: icap_product_master**\n- Columns (8): id, product_code, name, created_on, tenant_id, product_code_id, vendor_id, external_product_id\n- Joins with: vendor_id \u2192 icap_vendor\n\n\u26a0\ufe0f IMPORTANT: This is just a preview. You must still call postgres_inspect_schema() for each table before writing queries to get complete column lists and relationships.",
                "generated_at": "2026-01-02T18:48:34.481004",
                "configuration": {
                    "trigger_type": "date_range",
                    "output_format": "text",
                    "prompt": "You are a tax validation specialist. Review invoices and verify that tax amounts are correctly calculated based on subtotal. Flag any discrepancies where calculated tax doesn't match reported tax. Include invoice details, vendor info, and variance analysis. Use postgres_inspect_schema first."
                }
            }
        },
        "use_cases": [
            "Tax compliance",
            "Audit preparation",
            "Invoice error detection"
        ]
    },
    {
        "id": "product-category-spend",
        "name": "Product Category Spend Analysis",
        "description": "Analyze spending by product categories with GL mappings and vendor breakdown",
        "category": "Analytics",
        "icon": "TrendingUp",
        "template": {
            "prompt": "You are a category spend analyst. Analyze spending patterns across product categories using GL category mappings. Show total spend per category, number of invoices, line items, vendors contributing to each category, and detailed product breakdowns. Use postgres_inspect_schema first.",
            "trigger_type": "date_range",
            "input_fields": [
                {
                    "name": "start_date",
                    "type": "date",
                    "label": "Start Date"
                },
                {
                    "name": "end_date",
                    "type": "date",
                    "label": "End Date"
                }
            ],
            "tools": [
                "postgres_query",
                "postgres_inspect_schema"
            ],
            "default_visualization_preferences": "pie chart showing spend distribution by category, bar chart comparing category totals, bar chart showing top products by spend",
            "execution_guidance": {
                "query_template": {
                    "base_query": "SELECT\n    d.batch_name AS batch_name,\n    pm.name AS product_name,\n    pm.product_code AS product_code,\n    tcm.name AS category_name,\n    g.name AS gl_name,\n    g.code AS gl_code,\n    (ivd.description->>'value')::text AS product_description,\n    (ivd.item_code->>'value')::text AS item_code,\n    v.name AS vendor_name,\n    CASE WHEN (ivd.unit_price->>'value') != '' THEN (ivd.unit_price->>'value')::numeric ELSE 0 END AS item_unit_price,\n    CASE WHEN (ivd.quantity->>'value') != '' THEN (ivd.quantity->>'value')::numeric ELSE 0 END AS quantity,\n    i.invoice_date->>'value' AS invoice_date\nFROM icap_invoice_detail ivd\nLEFT JOIN icap_invoice i ON ivd.document_id = i.document_id\nINNER JOIN icap_document d ON i.document_id = d.id\nLEFT JOIN icap_vendor v ON i.vendor_id = v.id\nLEFT JOIN icap_product_master pm ON (ivd.product_id->>'value') != '' AND (ivd.product_id->>'value')::uuid = pm.id\nLEFT JOIN icap_product_category_mapping pcm ON pm.id = pcm.product_id\nLEFT JOIN icap_tenant_category_master tcm ON pcm.gl_category_id = tcm.id\nLEFT JOIN icap_tenant_gl_category_mapping tgcm ON tcm.id = tgcm.category_id\nLEFT JOIN icap_gl g ON tgcm.gl_id = g.id\nWHERE TO_DATE(i.invoice_date->>'value', 'MM/DD/YYYY') BETWEEN TO_DATE('{start_date}', 'MM/DD/YYYY') AND TO_DATE('{end_date}', 'MM/DD/YYYY')\nORDER BY item_unit_price DESC;",
                    "parameters": [
                        "start_date",
                        "end_date"
                    ],
                    "param_instructions": "Extract 'start_date' and 'end_date' from input_fields in MM/DD/YYYY format.",
                    "description": "Category-level spend analysis with product details, vendor breakdown, quantities, and spend percentage distribution.",
                    "where_clause": "WHERE (i.invoice_date->>'value' >= '{start_date}' AND i.invoice_date->>'value' <= '{end_date}')\n    GROUP BY \n        pm.name,\n        pm.product_code,\n        tcm.name,\n        g.name,\n        g.code,\n        (ivd.description->>'value')::text,\n        (ivd.item_code->>'value')::text,\n        v.name\n)\nSELECT\n    product_name,\n    product_code,\n    category_name,\n    gl_name,\n    gl_code,\n    product_description,\n    item_code,\n    vendor_name,\n    category_spend,\n    invoice_count,\n    line_item_count,\n    total_quantity,\n    ROUND((category_spend / NULLIF((SELECT SUM(category_spend) FROM category_spend), 0)) * 100, 2) AS spend_percentage\nFROM category_spend",
                    "full_template": "SELECT\n    d.batch_name AS batch_name,\n    pm.name AS product_name,\n    pm.product_code AS product_code,\n    tcm.name AS category_name,\n    g.name AS gl_name,\n    g.code AS gl_code,\n    (ivd.description->>'value')::text AS product_description,\n    (ivd.item_code->>'value')::text AS item_code,\n    v.name AS vendor_name,\n    CASE WHEN (ivd.unit_price->>'value') != '' THEN (ivd.unit_price->>'value')::numeric ELSE 0 END AS item_unit_price,\n    CASE WHEN (ivd.quantity->>'value') != '' THEN (ivd.quantity->>'value')::numeric ELSE 0 END AS quantity,\n    i.invoice_date->>'value' AS invoice_date\nFROM icap_invoice_detail ivd\nLEFT JOIN icap_invoice i ON ivd.document_id = i.document_id\nINNER JOIN icap_document d ON i.document_id = d.id\nLEFT JOIN icap_vendor v ON i.vendor_id = v.id\nLEFT JOIN icap_product_master pm ON (ivd.product_id->>'value') != '' AND (ivd.product_id->>'value')::uuid = pm.id\nLEFT JOIN icap_product_category_mapping pcm ON pm.id = pcm.product_id\nLEFT JOIN icap_tenant_category_master tcm ON pcm.gl_category_id = tcm.id\nLEFT JOIN icap_tenant_gl_category_mapping tgcm ON tcm.id = tgcm.category_id\nLEFT JOIN icap_gl g ON tgcm.gl_id = g.id\nWHERE TO_DATE(i.invoice_date->>'value', 'MM/DD/YYYY') BETWEEN TO_DATE('{start_date}', 'MM/DD/YYYY') AND TO_DATE('{end_date}', 'MM/DD/YYYY')\nORDER BY item_unit_price DESC;"
                },
                "execution_plan": {
                    "step_1": "Load pre-built query template from execution_guidance",
                    "step_2": "Extract 'start_date' and 'end_date' from input_fields in MM/DD/YYYY format.",
                    "step_3": "Replace template parameters: {start_date}, {end_date}",
                    "step_4": "Execute filled query using postgres_query tool",
                    "step_5": "Structure results as table_data with columns and rows arrays",
                    "step_6": "Include row_count and column metadata",
                    "step_7": "Return formatted table for interactive display"
                },
                "schema_context": "The database has been pre-inspected for your task. Key tables and columns:\n\n**Table: icap_invoice**\n- Columns (22): id, document_id, vendor_id, other_charges, credit_and_returns, invoice_number, invoice_date, due_date, tax, freight_charges, discount, total, sub_total, street, zip, city, country, state, payment_date, balance_amount, created_at, updated_at\n- JSONB columns (require ->> operator): other_charges, credit_and_returns, invoice_number, invoice_date, due_date, tax, freight_charges, discount, total, sub_total, street, zip, city, country, state, payment_date, balance_amount\n- Joins with: document_id \u2192 icap_document, vendor_id \u2192 icap_vendor\n- Related detail tables: icap_invoice_detail\n\n**Table: icap_invoice_detail**\n- Columns (13): id, document_id, uom, pack, size_numeric, size_unit, item_code, description, quantity, unit_price, total_price, category_id, product_id\n- JSONB columns (require ->> operator): uom, pack, size_numeric, size_unit, item_code, description, quantity, unit_price, total_price, category_id, product_id\n- Joins with: document_id \u2192 icap_document\n\n**Table: icap_vendor**\n- Columns (11): id, tenant_id, name, company, address, email, active, created_by, modified_by, created_on, modified_on\n- Related detail tables: icap_invoice, icap_product_master\n\n**Table: icap_product_master**\n- Columns (8): id, product_code, name, created_on, tenant_id, product_code_id, vendor_id, external_product_id\n- Joins with: vendor_id \u2192 icap_vendor\n\n\u26a0\ufe0f IMPORTANT: This is just a preview. You must still call postgres_inspect_schema() for each table before writing queries to get complete column lists and relationships.",
                "generated_at": "2026-01-02T18:48:34.481016",
                "configuration": {
                    "trigger_type": "date_range",
                    "output_format": "text",
                    "prompt": "You are a category spend analyst. Analyze spending patterns across product categories using GL category mappings. Show total spend per category, number of invoices, line items, vendors contributing to each category, and detailed product breakdowns. Use postgres_inspect_schema first."
                }
            }
        },
        "use_cases": [
            "Category management",
            "Budget allocation by category",
            "Vendor consolidation by category"
        ]
    }
]