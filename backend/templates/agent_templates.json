[
  {
    "id": "invoice-duplicate-detector",
    "name": "Invoice Duplicate Detector",
    "description": "Detects duplicate invoices based on invoice number, vendor, and amount to prevent payment errors",
    "category": "Finance & Accounting",
    "icon": "ðŸ”",
    "template": {
      "prompt": "You are an invoice duplicate detection specialist. Find duplicate invoices in the database by grouping invoices that have the same invoice number, vendor, and total amount. Show the count of duplicates and list all instances with invoice details, vendor information, dates, and amounts. Use postgres_inspect_schema first to understand the schema.",
      "trigger_type": "text_query",
      "input_fields": [],
      "tools": [
        "postgres_query",
        "postgres_inspect_schema"
      ],
      "default_visualization_preferences": "pie chart showing duplicate count distribution by vendor, bar chart comparing duplicate counts",
      "execution_guidance": {
        "query_template": {
          "base_query": "SELECT\n  STRING_AGG(d.batch_name, ', ') AS batch_names,\n  (i.invoice_number->>'value')::text AS invoice_number,\n  (i.total->>'value')::text AS total,\n  v.name AS vendor_name,\n  COUNT(*) AS duplicate_count\nFROM icap_invoice i\nLEFT JOIN icap_vendor v ON i.vendor_id = v.id\nINNER JOIN icap_document d ON i.document_id = d.id\nWHERE (i.total->>'value') IS NOT NULL AND (i.total->>'value') <> ''\nGROUP BY d.batch_name, invoice_number, total, vendor_name\nHAVING COUNT(*) > 1\nORDER BY duplicate_count DESC;",
          "where_clause": "",
          "parameters": [],
          "param_instructions": "No parameters required - scans all invoices.",
          "full_template": "SELECT\n  STRING_AGG(d.batch_name, ', ') AS batch_names,\n  (i.invoice_number->>'value')::text AS invoice_number,\n  (i.total->>'value')::text AS total,\n  v.name AS vendor_name,\n  COUNT(*) AS duplicate_count\nFROM icap_invoice i\nLEFT JOIN icap_vendor v ON i.vendor_id = v.id\nINNER JOIN icap_document d ON i.document_id = d.id\nWHERE (i.total->>'value') IS NOT NULL AND (i.total->>'value') <> ''\nGROUP BY invoice_number, total, vendor_name\nHAVING COUNT(*) > 1\nORDER BY duplicate_count DESC;"
        },
        "execution_plan": {
          "step_1": "Load pre-built query template from execution_guidance",
          "step_2": "No parameters required - scans all invoices.",
          "step_3": "Execute query directly using postgres_query tool",
          "step_4": "Structure results as table_data with columns and rows arrays",
          "step_5": "Include row_count and column metadata",
          "step_6": "Return formatted table for interactive display"
        },
        "schema_context": "The database has been pre-inspected for your task. Key tables and columns:\n\n**Table: icap_invoice**\n- Columns (22): id, document_id, vendor_id, other_charges, credit_and_returns, invoice_number, invoice_date, due_date, tax, freight_charges, discount, total, sub_total, street, zip, city, country, state, payment_date, balance_amount, created_at, updated_at\n- JSONB columns (require ->> operator): other_charges, credit_and_returns, invoice_number, invoice_date, due_date, tax, freight_charges, discount, total, sub_total, street, zip, city, country, state, payment_date, balance_amount\n- Joins with: document_id â†’ icap_document, vendor_id â†’ icap_vendor\n- Related detail tables: icap_invoice_detail\n\n**Table: icap_vendor**\n- Columns (11): id, tenant_id, name, company, address, email, active, created_by, modified_by, created_on, modified_on\n- Related detail tables: icap_invoice, icap_product_master\n\nâš ï¸ IMPORTANT: This is just a preview. You must still call postgres_inspect_schema() for each table before writing queries to get complete column lists and relationships.",
        "generated_at": "2026-01-02T18:45:00.000000",
        "configuration": {
          "trigger_type": "text_query",
          "output_format": "text",
          "prompt": "You are an invoice duplicate detection specialist. Find duplicate invoices in the database by grouping invoices that have the same invoice number, vendor, and total amount. Show the count of duplicates and list all instances with invoice details, vendor information, dates, and amounts. Use postgres_inspect_schema first to understand the schema."
        }
      }
    },
    "use_cases": [
      "Prevent duplicate payments",
      "Audit invoice records",
      "Clean up invoice database"
    ]
  },
  {
    "id": "invoice-approval-router",
    "name": "Invoice Auto-Approver (Confidence-Based)",
    "description": "Auto-approves invoices where all critical field confidence scores >= threshold (invoice + line items)",
    "category": "Workflow Management",
    "icon": "âœ…",
    "template": {
      "prompt": "You are an AI-driven invoice auto-approval agent.\n\nValidation Criteria:\n1. From icap_invoice (3 fields): invoice_number, invoice_date, due_date\n2. From icap_invoice_detail (3 fields): description, quantity, unit_price\n3. vendor_id is UUID (NO confidence check - skip it)\n4. ALL 6 JSONB fields must have confidence >= threshold\n5. Check BOTH header and ALL line items\n\nQuery Logic:\n- Join icap_invoice with icap_invoice_detail on document_id\n- Extract confidence: (column->>'confidence')::numeric\n- Filter: ALL 6 fields >= threshold\n- Update icap_document.status='3' (Approved) for qualifying invoices\n- Use dry-run workflow\n\nDefault threshold: 95.0",
      "trigger_type": "conditions",
      "input_fields": [
        {
          "name": "threshold",
          "type": "text",
          "label": "Threshold (%)",
          "description": "Enter the confidence threshold percentage (e.g., 95.0 for 95%)"
        }
      ],
      "output_format": "text",
      "tools": [
        "postgres_query",
        "postgres_inspect_schema",
        "postgres_write"
      ],
      "default_visualization_preferences": "bar chart showing confidence scores distribution, pie chart by validation status",
      "execution_guidance": {
        "query_template": {
          "base_query": "WITH invoice_detail_confidence AS (\n    SELECT \n        ivd.document_id,\n        MIN((ivd.description->>'confidence')::numeric) AS min_desc_conf,\n        MIN((ivd.quantity->>'confidence')::numeric) AS min_qty_conf,\n        MIN((ivd.unit_price->>'confidence')::numeric) AS min_price_conf,\n        COUNT(*) AS line_count\n    FROM icap_invoice_detail ivd\n    GROUP BY ivd.document_id\n    HAVING MIN((ivd.description->>'confidence')::numeric) >= {threshold}\n        AND MIN((ivd.quantity->>'confidence')::numeric) >= {threshold}\n        AND MIN((ivd.unit_price->>'confidence')::numeric) >= {threshold}\n)\nSELECT\n    d.batch_name,\n    d.accuracy,\n    (i.invoice_number->>'value')::text AS invoice_number,\n    (i.invoice_number->>'confidence')::numeric AS inv_num_conf,\n    (i.invoice_date->>'value')::text AS invoice_date,\n    (i.invoice_date->>'confidence')::numeric AS inv_date_conf,\n    (i.due_date->>'value')::text AS due_date,\n    (i.due_date->>'confidence')::numeric AS due_date_conf,\n    v.name AS vendor_name,\n    idc.line_count,\n    idc.min_desc_conf,\n    idc.min_qty_conf,\n    idc.min_price_conf,\n    LEAST(\n        (i.invoice_number->>'confidence')::numeric,\n        (i.invoice_date->>'confidence')::numeric,\n        (i.due_date->>'confidence')::numeric,\n        idc.min_desc_conf,\n        idc.min_qty_conf,\n        idc.min_price_conf\n    ) AS overall_min_confidence,\n    d.status\nFROM icap_invoice i\nLEFT JOIN icap_vendor v ON i.vendor_id = v.id\nINNER JOIN icap_document d ON i.document_id = d.id\nINNER JOIN invoice_detail_confidence idc ON i.document_id = idc.document_id\nWHERE d.status = '2' AND d.sub_status = '15'\n  AND (i.invoice_number->>'confidence')::numeric >= {threshold}\n  AND (i.invoice_date->>'confidence')::numeric >= {threshold}\n  AND (i.due_date->>'confidence')::numeric >= {threshold}\nORDER BY overall_min_confidence DESC;",
          "parameters": [
            "threshold"
          ],
          "param_instructions": "Extract 'threshold' from user query (e.g., 'confidence above 90' â†’ 90.0, 'accuracy 85%' â†’ 85.0). Default: 95.0",
          "description": "Validates 6 critical fields: invoice_number, invoice_date, due_date (header) + description, quantity, unit_price (ALL line items). vendor_id is UUID - no confidence check.",
          "where_clause": "WHERE d.status = '2' AND d.sub_status = '15' AND all 6 JSONB fields >= {threshold}",
          "full_template": "WITH invoice_detail_confidence AS (\n    SELECT \n        ivd.document_id,\n        MIN((ivd.description->>'confidence')::numeric) AS min_desc_conf,\n        MIN((ivd.quantity->>'confidence')::numeric) AS min_qty_conf,\n        MIN((ivd.unit_price->>'confidence')::numeric) AS min_price_conf,\n        COUNT(*) AS line_count\n    FROM icap_invoice_detail ivd\n    GROUP BY ivd.document_id\n    HAVING MIN((ivd.description->>'confidence')::numeric) >= {threshold}\n        AND MIN((ivd.quantity->>'confidence')::numeric) >= {threshold}\n        AND MIN((ivd.unit_price->>'confidence')::numeric) >= {threshold}\n)\nSELECT\n    d.batch_name,\n    d.accuracy,\n    (i.invoice_number->>'value')::text AS invoice_number,\n    (i.invoice_number->>'confidence')::numeric AS inv_num_conf,\n    (i.invoice_date->>'value')::text AS invoice_date,\n    (i.invoice_date->>'confidence')::numeric AS inv_date_conf,\n    (i.due_date->>'value')::text AS due_date,\n    (i.due_date->>'confidence')::numeric AS due_date_conf,\n    v.name AS vendor_name,\n    idc.line_count,\n    idc.min_desc_conf,\n    idc.min_qty_conf,\n    idc.min_price_conf,\n    LEAST(\n        (i.invoice_number->>'confidence')::numeric,\n        (i.invoice_date->>'confidence')::numeric,\n        (i.due_date->>'confidence')::numeric,\n        idc.min_desc_conf,\n        idc.min_qty_conf,\n        idc.min_price_conf\n    ) AS overall_min_confidence,\n    d.status\nFROM icap_invoice i\nLEFT JOIN icap_vendor v ON i.vendor_id = v.id\nINNER JOIN icap_document d ON i.document_id = d.id\nINNER JOIN invoice_detail_confidence idc ON i.document_id = idc.document_id\nWHERE d.status = '2' AND d.sub_status = '15'\n  AND (i.invoice_number->>'confidence')::numeric >= {threshold}\n  AND (i.invoice_date->>'confidence')::numeric >= {threshold}\n  AND (i.due_date->>'confidence')::numeric >= {threshold}\nORDER BY overall_min_confidence DESC;"
        },
        "execution_plan": {
          "step_1": "Extract threshold from user query (default: 95.0)",
          "step_2": "Use CTE to aggregate line item confidence scores (MIN across ALL line items)",
          "step_3": "Join invoice header with aggregated line item confidence",
          "step_4": "Filter: status='2' AND sub_status='15' (icap_document) AND all 6 fields (3 header + 3 detail) >= threshold",
          "step_5": "SKIP vendor_id validation (it's UUID, no confidence attribute)",
          "step_6": "For EACH qualifying invoice: UPDATE icap_document SET status='3' WHERE id='{document_id}'",
          "step_7": "Execute postgres_write with dry_run=True first",
          "step_8": "If OK, execute postgres_write with dry_run=False",
          "step_9": "Report: invoice_number, vendor, line_count, confidence scores, status",
          "step_10": "Return formatted table with approved invoices"
        },
        "schema_context": "**Critical Fields Validation:**\n\n**icap_invoice (Header - 3 JSONB fields):**\n- invoice_number (JSONB) - has confidence\n- invoice_date (JSONB) - has confidence\n- due_date (JSONB) - has confidence\n- vendor_id (UUID) - NO confidence attribute, skip validation\n\n**icap_invoice_detail (Line Items - 3 JSONB fields):**\n- description (JSONB) - has confidence\n- quantity (JSONB) - has confidence\n- unit_price (JSONB) - has confidence\n\n**Validation Logic:**\n- Check ALL 6 JSONB fields >= threshold\n- Use MIN() across all line items (strictest validation)\n- INNER JOIN ensures invoices have line items\n- status ENUM (icap_document): '0'=New, '2'=Needs Review, '3'=Approved\n\n**JSONB Structure:** {\"value\": \"data\", \"confidence\": 98.5, \"pageNo\": 1}",
        "generated_at": "2026-01-05T12:35:00.000000",
        "configuration": {
          "trigger_type": "text_query",
          "output_format": "text",
          "prompt": "AI-driven invoice auto-approval. Validates 6 critical fields (invoice_number, invoice_date, due_date, description, quantity, unit_price). Updates status for 'In Progress' documents (status=2, sub_status=15) with high confidence."
        }
      }
    },
    "use_cases": [
      "Auto-approve high-confidence invoices with line items",
      "Validate OCR accuracy across header and details",
      "Fast-track complete invoices to payment"
    ]
  },
  {
    "id": "vendor-gl-breakdown",
    "name": "Vendor GL Breakdown Report",
    "description": "Generate GL breakdown reports for invoices from specific vendors with category mappings",
    "category": "Finance & Accounting",
    "icon": "ðŸ“‘",
    "template": {
      "prompt": "You are a GL reporting specialist. Generate comprehensive GL breakdown reports for invoices from specific vendors. Include invoice details, line item descriptions, quantities, amounts, and GL category mappings for each line item. Use postgres_inspect_schema first to understand the schema structure and relationships.",
      "trigger_type": "conditions",
      "input_fields": [
        {
          "name": "vendor_name",
          "type": "text",
          "label": "Vendor Name",
          "description": "Enter the vendor name for the GL breakdown report"
        }
      ],
      "output_format": "text",
      "tools": [
        "postgres_query",
        "postgres_inspect_schema"
      ],
      "default_visualization_preferences": "pie chart showing GL category distribution, bar chart comparing line totals by category",
      "execution_guidance": {
        "query_template": {
          "base_query": "SELECT\n    d.batch_name AS batch_name,\n    (i.invoice_number->>'value')::text AS invoice_number,\n    (i.invoice_date->>'value')::text AS invoice_date,\n    NULLIF(i.total->>'value', '')::numeric AS invoice_total,\n    (i.sub_total->>'value')::text AS subtotal,\n    (i.tax->>'value')::text AS tax,\n    v.name AS vendor_name,\n    v.company AS vendor_company,\n    (ivd.description->>'value')::text AS line_item_description,\n    (ivd.item_code->>'value')::text AS item_code,\n    (ivd.quantity->>'value')::text AS quantity,\n    (ivd.unit_price->>'value')::text AS unit_price,\n    NULLIF(ivd.total_price->>'value', '')::numeric AS line_total,\n    pm.name AS product_name,\n    pm.product_code AS product_code,\n    tcm.name AS category_name,\n    g.name AS gl_name,\n    g.code AS gl_code,\n    g.account_type AS gl_account_type\nFROM icap_invoice i\nLEFT JOIN icap_vendor v ON i.vendor_id = v.id\nINNER JOIN icap_document d ON i.document_id = d.id\nLEFT JOIN icap_invoice_detail ivd ON ivd.document_id = i.document_id\nLEFT JOIN icap_product_master pm ON pm.vendor_id = v.id\nLEFT JOIN icap_product_category_mapping pcm ON pm.id = pcm.product_id\nLEFT JOIN icap_tenant_category_master tcm ON pcm.gl_category_id = tcm.id\nLEFT JOIN icap_tenant_gl_category_mapping tgcm ON tcm.id = tgcm.category_id\nLEFT JOIN icap_gl g ON tgcm.gl_id = g.id\nWHERE v.name ILIKE '%{vendor_name}%'\nORDER BY i.invoice_number->>'value', ivd.id;",
          "parameters": [
            "vendor_name"
          ],
          "param_instructions": "Extract 'vendor_name' from user query. Use partial matching with ILIKE for flexibility.",
          "description": "Complete GL breakdown with invoice header, line items, GL categories, and product mappings for specified vendor.",
          "where_clause": "WHERE v.name ILIKE '%{vendor_name}%'",
          "full_template": "SELECT\n    d.batch_name AS batch_name,\n    (i.invoice_number->>'value')::text AS invoice_number,\n    (i.invoice_date->>'value')::text AS invoice_date,\n    NULLIF(i.total->>'value', '')::numeric AS invoice_total,\n    (i.sub_total->>'value')::text AS subtotal,\n    (i.tax->>'value')::text AS tax,\n    v.name AS vendor_name,\n    v.company AS vendor_company,\n    (ivd.description->>'value')::text AS line_item_description,\n    (ivd.item_code->>'value')::text AS item_code,\n    (ivd.quantity->>'value')::text AS quantity,\n    (ivd.unit_price->>'value')::text AS unit_price,\n    NULLIF(ivd.total_price->>'value', '')::numeric AS line_total,\n    pm.name AS product_name,\n    pm.product_code AS product_code,\n    tcm.name AS category_name,\n    g.name AS gl_name,\n    g.code AS gl_code,\n    g.account_type AS gl_account_type\nFROM icap_invoice i\nLEFT JOIN icap_vendor v ON i.vendor_id = v.id\nINNER JOIN icap_document d ON i.document_id = d.id\nLEFT JOIN icap_invoice_detail ivd ON ivd.document_id = i.document_id\nLEFT JOIN icap_product_master pm ON pm.vendor_id = v.id\nLEFT JOIN icap_product_category_mapping pcm ON pm.id = pcm.product_id\nLEFT JOIN icap_tenant_category_master tcm ON pcm.gl_category_id = tcm.id\nLEFT JOIN icap_tenant_gl_category_mapping tgcm ON tcm.id = tgcm.category_id\nLEFT JOIN icap_gl g ON tgcm.gl_id = g.id\nWHERE v.name ILIKE '%{vendor_name}%'\nORDER BY i.invoice_number->>'value', ivd.id;"
        },
        "execution_plan": {
          "step_1": "Load pre-built query template from execution_guidance",
          "step_2": "Extract 'vendor_name' from user query. Use partial matching with ILIKE for flexibility.",
          "step_3": "Replace template parameters: {vendor_name}",
          "step_4": "Execute filled query using postgres_query tool",
          "step_5": "Structure results as table_data with columns and rows arrays",
          "step_6": "Include row_count and column metadata",
          "step_7": "Return formatted table for interactive display"
        },
        "schema_context": "The database has been pre-inspected for your task. Key tables and columns:\n\n**Table: icap_invoice**\n- Columns (22): id, document_id, vendor_id, other_charges, credit_and_returns, invoice_number, invoice_date, due_date, tax, freight_charges, discount, total, sub_total, street, zip, city, country, state, payment_date, balance_amount, created_at, updated_at\n- JSONB columns (require ->> operator): other_charges, credit_and_returns, invoice_number, invoice_date, due_date, tax, freight_charges, discount, total, sub_total, street, zip, city, country, state, payment_date, balance_amount\n- Joins with: document_id â†’ icap_document, vendor_id â†’ icap_vendor\n- Related detail tables: icap_invoice_detail\n\n**Table: icap_invoice_detail**\n- Columns (13): id, document_id, uom, pack, size_numeric, size_unit, item_code, description, quantity, unit_price, total_price, category_id, product_id\n- JSONB columns (require ->> operator): uom, pack, size_numeric, size_unit, item_code, description, quantity, unit_price, total_price, category_id, product_id\n- Joins with: document_id â†’ icap_document\n\n**Table: icap_vendor**\n- Columns (11): id, tenant_id, name, company, address, email, active, created_by, modified_by, created_on, modified_on\n- Related detail tables: icap_invoice, icap_product_master\n\n**Table: icap_product_master**\n- Columns (8): id, product_code, name, created_on, tenant_id, product_code_id, vendor_id, external_product_id\n- Joins with: vendor_id â†’ icap_vendor\n\nâš ï¸ IMPORTANT: This is just a preview. You must still call postgres_inspect_schema() for each table before writing queries to get complete column lists and relationships.",
        "generated_at": "2026-01-02T18:48:34.480921",
        "configuration": {
          "trigger_type": "text_query",
          "output_format": "text",
          "prompt": "You are a GL reporting specialist. Generate comprehensive GL breakdown reports for invoices from specific vendors. Include invoice details, line item descriptions, quantities, amounts, and GL category mappings for each line item. Use postgres_inspect_schema first to understand the schema structure and relationships."
        }
      }
    },
    "use_cases": [
      "GL account reconciliation",
      "Vendor-specific expense analysis",
      "Category-based reporting"
    ]
  },
  {
    "id": "invoice-payment-audit",
    "name": "Invoice Payment Status Auditor",
    "description": "Audit invoices within a date range to check for payment status and identify issues",
    "category": "Accounts Payable",
    "icon": "ðŸ”Ž",
    "template": {
      "prompt": "You are an invoice audit specialist. Audit all invoices within a specified date range to check payment status, identify unpaid invoices, overdue invoices, and payment delays. Include invoice details, vendor information, due dates, payment dates, and outstanding balances. Use postgres_inspect_schema first to understand the schema.",
      "trigger_type": "date_range",
      "input_fields": [
        {
          "name": "start_date",
          "type": "date",
          "label": "Start Date"
        },
        {
          "name": "end_date",
          "type": "date",
          "label": "End Date"
        }
      ],
      "tools": [
        "postgres_query",
        "postgres_inspect_schema"
      ],
      "default_visualization_preferences": "pie chart showing payment status distribution, bar chart comparing amounts by status",
      "execution_guidance": {
        "query_template": {
          "base_query": "SELECT\n    d.batch_name AS batch_name,\n    (i.invoice_number->>'value')::text AS invoice_number,\n    (i.invoice_date->>'value')::text AS invoice_date,\n    (i.due_date->>'value')::text AS due_date,\n    (i.payment_date->>'value')::text AS payment_date,\n    NULLIF(i.total->>'value', '')::numeric AS total_amount,\n    (i.balance_amount->>'value')::text AS balance_due,\n    v.name AS vendor_name,\n    v.company AS vendor_company,\n,\n    CASE \n        WHEN i.payment_date->>'value' IS NOT NULL AND i.payment_date->>'value' != '' THEN 'Paid'\n        WHEN i.due_date->>'value' < CURRENT_DATE::text THEN 'Overdue'\n        WHEN i.balance_amount->>'value' IS NOT NULL AND i.balance_amount->>'value' != '' AND (i.balance_amount->>'value')::numeric > 0 THEN 'Partially Paid'\n        ELSE 'Unpaid'\n    END AS payment_status\nFROM icap_invoice i\nLEFT JOIN icap_vendor v ON i.vendor_id = v.id\nINNER JOIN icap_document d ON i.document_id = d.id\nWHERE (i.invoice_date->>'value' >= '{start_date}' AND i.invoice_date->>'value' <= '{end_date}')\nORDER BY \n    CASE \n        WHEN i.due_date->>'value' < CURRENT_DATE::text THEN 1\n        WHEN i.payment_date->>'value' IS NULL OR i.payment_date->>'value' = '' THEN 2\n        ELSE 3\n    END,\n    i.due_date->>'value',\n    CASE WHEN (i.total->>'value') != '' THEN (i.total->>'value')::numeric ELSE 0 END DESC;",
          "parameters": [
            "start_date",
            "end_date"
          ],
          "param_instructions": "Extract 'start_date' and 'end_date' from input_fields in MM/DD/YYYY format matching JSONB date format.",
          "description": "Comprehensive payment audit with status categorization, prioritizing overdue and unpaid invoices first.",
          "where_clause": "WHERE (i.invoice_date->>'value' >= '{start_date}' AND i.invoice_date->>'value' <= '{end_date}')",
          "full_template": "SELECT\n    d.batch_name AS batch_name,\n    (i.invoice_number->>'value')::text AS invoice_number,\n    (i.invoice_date->>'value')::text AS invoice_date,\n    (i.due_date->>'value')::text AS due_date,\n    (i.payment_date->>'value')::text AS payment_date,\n    NULLIF(i.total->>'value', '')::numeric AS total_amount,\n    (i.balance_amount->>'value')::text AS balance_due,\n    v.name AS vendor_name,\n    v.company AS vendor_company,\n,\n    CASE \n        WHEN i.payment_date->>'value' IS NOT NULL AND i.payment_date->>'value' != '' THEN 'Paid'\n        WHEN i.due_date->>'value' < CURRENT_DATE::text THEN 'Overdue'\n        WHEN i.balance_amount->>'value' IS NOT NULL AND i.balance_amount->>'value' != '' AND (i.balance_amount->>'value')::numeric > 0 THEN 'Partially Paid'\n        ELSE 'Unpaid'\n    END AS payment_status\nFROM icap_invoice i\nLEFT JOIN icap_vendor v ON i.vendor_id = v.id\nINNER JOIN icap_document d ON i.document_id = d.id\nWHERE (i.invoice_date->>'value' >= '{start_date}' AND i.invoice_date->>'value' <= '{end_date}')\nORDER BY \n    CASE \n        WHEN i.due_date->>'value' < CURRENT_DATE::text THEN 1\n        WHEN i.payment_date->>'value' IS NULL OR i.payment_date->>'value' = '' THEN 2\n        ELSE 3\n    END,\n    i.due_date->>'value',\n    CASE WHEN (i.total->>'value') != '' THEN (i.total->>'value')::numeric ELSE 0 END DESC;"
        },
        "execution_plan": {
          "step_1": "Load pre-built query template from execution_guidance",
          "step_2": "Extract 'start_date' and 'end_date' from input_fields in MM/DD/YYYY format matching JSONB date format.",
          "step_3": "Replace template parameters: {start_date}, {end_date}",
          "step_4": "Execute filled query using postgres_query tool",
          "step_5": "Structure results as table_data with columns and rows arrays",
          "step_6": "Include row_count and column metadata",
          "step_7": "Return formatted table for interactive display"
        },
        "schema_context": "The database has been pre-inspected for your task. Key tables and columns:\n\n**Table: icap_invoice**\n- Columns (22): id, document_id, vendor_id, other_charges, credit_and_returns, invoice_number, invoice_date, due_date, tax, freight_charges, discount, total, sub_total, street, zip, city, country, state, payment_date, balance_amount, created_at, updated_at\n- JSONB columns (require ->> operator): other_charges, credit_and_returns, invoice_number, invoice_date, due_date, tax, freight_charges, discount, total, sub_total, street, zip, city, country, state, payment_date, balance_amount\n- Joins with: document_id â†’ icap_document, vendor_id â†’ icap_vendor\n- Related detail tables: icap_invoice_detail\n\n**Table: icap_invoice_detail**\n- Columns (13): id, document_id, uom, pack, size_numeric, size_unit, item_code, description, quantity, unit_price, total_price, category_id, product_id\n- JSONB columns (require ->> operator): uom, pack, size_numeric, size_unit, item_code, description, quantity, unit_price, total_price, category_id, product_id\n- Joins with: document_id â†’ icap_document\n\n**Table: icap_vendor**\n- Columns (11): id, tenant_id, name, company, address, email, active, created_by, modified_by, created_on, modified_on\n- Related detail tables: icap_invoice, icap_product_master\n\n**Table: icap_product_master**\n- Columns (8): id, product_code, name, created_on, tenant_id, product_code_id, vendor_id, external_product_id\n- Joins with: vendor_id â†’ icap_vendor\n\nâš ï¸ IMPORTANT: This is just a preview. You must still call postgres_inspect_schema() for each table before writing queries to get complete column lists and relationships.",
        "generated_at": "2026-01-02T18:48:34.480936",
        "configuration": {
          "trigger_type": "date_range",
          "output_format": "text",
          "prompt": "You are an invoice audit specialist. Audit all invoices within a specified date range to check payment status, identify unpaid invoices, overdue invoices, and payment delays. Include invoice details, vendor information, due dates, payment dates, and outstanding balances. Use postgres_inspect_schema first to understand the schema."
        }
      }
    },
    "use_cases": [
      "Payment compliance audit",
      "Identify payment delays",
      "Manage payables effectively"
    ]
  },
  {
    "id": "invoice-missing-data-detector",
    "name": "Invoice Missing Data Detector",
    "description": "Detects invoices missing critical details and flags them for review (status='2') with vendor contact info",
    "category": "Data Quality",
    "icon": "âš ï¸",
    "template": {
      "prompt": "You are a data quality specialist. Scan all invoices to detect missing or incomplete critical details like invoice number, invoice date, due date, total amount, or vendor information. For invoices with issues, update icap_document.status to '2' (Needs Review) and provide vendor contact information for follow-up. Use postgres_inspect_schema first, then identify issues, update status using postgres_write. Note that status is not payment status",
      "trigger_type": "text_query",
      "input_fields": [],
      "tools": [
        "postgres_query",
        "postgres_inspect_schema",
        "postgres_write"
      ],
      "default_visualization_preferences": "bar chart showing data issue types distribution, pie chart by vendor showing missing data patterns",
      "execution_guidance": {
        "query_template": {
          "base_query": "SELECT\n    d.batch_name AS batch_name,\n    (i.invoice_number->>'value')::text AS invoice_number,\n    (i.invoice_date->>'value')::text AS invoice_date,\n    (i.due_date->>'value')::text AS due_date,\n    (i.total->>'value')::text AS total_amount,\n    v.name AS vendor_name,\n    v.company AS vendor_company,\n,\n    v.address AS vendor_address,\n    CASE \n        WHEN (i.invoice_number->>'value' IS NULL OR i.invoice_number->>'value' = '') THEN 'Missing Invoice Number'\n        WHEN (i.invoice_date->>'value' IS NULL OR i.invoice_date->>'value' = '') THEN 'Missing Invoice Date'\n        WHEN (i.due_date->>'value' IS NULL OR i.due_date->>'value' = '') THEN 'Missing Due Date'\n        WHEN (i.total->>'value' IS NULL OR i.total->>'value' = '') THEN 'Missing Total Amount'\n        WHEN v.id IS NULL THEN 'Missing Vendor'\n \n        ELSE 'Incomplete Data'\n    END AS data_issue,\n    ARRAY_REMOVE(ARRAY[\n        CASE WHEN (i.invoice_number->>'value' IS NULL OR i.invoice_number->>'value' = '') THEN 'invoice_number' END,\n        CASE WHEN (i.invoice_date->>'value' IS NULL OR i.invoice_date->>'value' = '') THEN 'invoice_date' END,\n        CASE WHEN (i.due_date->>'value' IS NULL OR i.due_date->>'value' = '') THEN 'due_date' END,\n        CASE WHEN (i.total->>'value' IS NULL OR i.total->>'value' = '') THEN 'total' END,\n        CASE WHEN v.id IS NULL THEN 'vendor' END\n    ], NULL) AS missing_fields\nFROM icap_invoice i\nLEFT JOIN icap_vendor v ON i.vendor_id = v.id\nINNER JOIN icap_document d ON i.document_id = d.id\nWHERE \n    (i.invoice_number->>'value' IS NULL OR i.invoice_number->>'value' = '')\n    OR (i.invoice_date->>'value' IS NULL OR i.invoice_date->>'value' = '')\n    OR (i.due_date->>'value' IS NULL OR i.due_date->>'value' = '')\n    OR (i.total->>'value' IS NULL OR i.total->>'value' = '')\n    OR v.id IS NULL\n\nORDER BY \n    CASE \n        WHEN (i.total->>'value' IS NULL OR i.total->>'value' = '') THEN 1\n        WHEN (i.invoice_number->>'value' IS NULL OR i.invoice_number->>'value' = '') THEN 2\n        WHEN v.id IS NULL THEN 3\n        ELSE 4\n    END,\n    v.name;",
          "parameters": [],
          "param_instructions": "No parameters required - scans all invoices for data quality issues.",
          "description": "Detects invoices with missing critical fields, categorizes data issues, and provides vendor contact info for follow-up.",
          "where_clause": "WHERE (i.invoice_number->>'value' IS NULL OR i.invoice_number->>'value' = '')\n    OR (i.invoice_date->>'value' IS NULL OR i.invoice_date->>'value' = '')\n    OR (i.due_date->>'value' IS NULL OR i.due_date->>'value' = '')\n    OR (i.total->>'value' IS NULL OR i.total->>'value' = '')\n    OR v.id IS NULL\n",
          "full_template": "SELECT\n    d.batch_name AS batch_name,\n    (i.invoice_number->>'value')::text AS invoice_number,\n    (i.invoice_date->>'value')::text AS invoice_date,\n    (i.due_date->>'value')::text AS due_date,\n    (i.total->>'value')::text AS total_amount,\n    v.name AS vendor_name,\n    v.company AS vendor_company,\n,\n    v.address AS vendor_address,\n    CASE \n        WHEN (i.invoice_number->>'value' IS NULL OR i.invoice_number->>'value' = '') THEN 'Missing Invoice Number'\n        WHEN (i.invoice_date->>'value' IS NULL OR i.invoice_date->>'value' = '') THEN 'Missing Invoice Date'\n        WHEN (i.due_date->>'value' IS NULL OR i.due_date->>'value' = '') THEN 'Missing Due Date'\n        WHEN (i.total->>'value' IS NULL OR i.total->>'value' = '') THEN 'Missing Total Amount'\n        WHEN v.id IS NULL THEN 'Missing Vendor'\n \n        ELSE 'Incomplete Data'\n    END AS data_issue,\n    ARRAY_REMOVE(ARRAY[\n        CASE WHEN (i.invoice_number->>'value' IS NULL OR i.invoice_number->>'value' = '') THEN 'invoice_number' END,\n        CASE WHEN (i.invoice_date->>'value' IS NULL OR i.invoice_date->>'value' = '') THEN 'invoice_date' END,\n        CASE WHEN (i.due_date->>'value' IS NULL OR i.due_date->>'value' = '') THEN 'due_date' END,\n        CASE WHEN (i.total->>'value' IS NULL OR i.total->>'value' = '') THEN 'total' END,\n        CASE WHEN v.id IS NULL THEN 'vendor' END\n    ], NULL) AS missing_fields\nFROM icap_invoice i\nLEFT JOIN icap_vendor v ON i.vendor_id = v.id\nINNER JOIN icap_document d ON i.document_id = d.id\nWHERE \n    (i.invoice_number->>'value' IS NULL OR i.invoice_number->>'value' = '')\n    OR (i.invoice_date->>'value' IS NULL OR i.invoice_date->>'value' = '')\n    OR (i.due_date->>'value' IS NULL OR i.due_date->>'value' = '')\n    OR (i.total->>'value' IS NULL OR i.total->>'value' = '')\n    OR v.id IS NULL\n\nORDER BY \n    CASE \n        WHEN (i.total->>'value' IS NULL OR i.total->>'value' = '') THEN 1\n        WHEN (i.invoice_number->>'value' IS NULL OR i.invoice_number->>'value' = '') THEN 2\n        WHEN v.id IS NULL THEN 3\n        ELSE 4\n    END,\n    v.name;"
        },
        "execution_plan": {
          "step_1": "Load pre-built query template from execution_guidance",
          "step_2": "No parameters required",
          "step_3": "Execute query directly using postgres_query tool to find invoices with missing data",
          "step_4": "For EACH invoice found with missing data, prepare UPDATE query: UPDATE icap_document SET status='2' WHERE id=(SELECT document_id FROM icap_invoice WHERE id={invoice_id})",
          "step_5": "Execute postgres_write with dry_run=True first to preview status updates",
          "step_6": "If preview looks good, execute postgres_write with dry_run=False to flag invoices with status='2' (Needs Review)",
          "step_7": "Structure results showing flagged invoices with data quality issues and vendor contact info",
          "step_8": "Include row_count and affected_rows metadata",
          "step_9": "Return formatted table with flagged invoices and follow-up recommendations"
        },
        "schema_context": "The database has been pre-inspected for your task. Key tables and columns:\n\n**Table: icap_invoice**\n- Columns (22): id, document_id, vendor_id, other_charges, credit_and_returns, invoice_number, invoice_date, due_date, tax, freight_charges, discount, total, sub_total, street, zip, city, country, state, payment_date, balance_amount, created_at, updated_at\n- JSONB columns (require ->> operator): other_charges, credit_and_returns, invoice_number, invoice_date, due_date, tax, freight_charges, discount, total, sub_total, street, zip, city, country, state, payment_date, balance_amount\n- Joins with: document_id â†’ icap_document, vendor_id â†’ icap_vendor\n- Related detail tables: icap_invoice_detail\n\n**Table: icap_invoice_detail**\n- Columns (13): id, document_id, uom, pack, size_numeric, size_unit, item_code, description, quantity, unit_price, total_price, category_id, product_id\n- JSONB columns (require ->> operator): uom, pack, size_numeric, size_unit, item_code, description, quantity, unit_price, total_price, category_id, product_id\n- Joins with: document_id â†’ icap_document\n\n**Table: icap_vendor**\n- Columns (11): id, tenant_id, name, company, address, email, active, created_by, modified_by, created_on, modified_on\n- Related detail tables: icap_invoice, icap_product_master\n\n**Table: icap_product_master**\n- Columns (8): id, product_code, name, created_on, tenant_id, product_code_id, vendor_id, external_product_id\n- Joins with: vendor_id â†’ icap_vendor\n\nâš ï¸ IMPORTANT: This is just a preview. You must still call postgres_inspect_schema() for each table before writing queries to get complete column lists and relationships.",
        "generated_at": "2026-01-02T18:48:34.480954",
        "configuration": {
          "trigger_type": "text_query",
          "output_format": "text",
          "prompt": "You are a data quality specialist. Scan all invoices to detect missing or incomplete critical details like invoice number, invoice date, due date, total amount, or vendor information. Generate a report listing problematic invoices with vendor email addresses for follow-up communication. Use postgres_inspect_schema first to understand the schema."
        }
      }
    },
    "use_cases": [
      "Data cleanup campaigns",
      "Vendor communication for missing info",
      "Improve invoice data quality",
      "Automated follow-up workflows",
      "Proactive data quality management"
    ]
  },
  {
    "id": "monthly-expense-report",
    "name": "Monthly Expense Report",
    "description": "Generate comprehensive monthly expense reports with totals, breakdowns by category, and vendor analysis",
    "category": "Finance & Accounting",
    "icon": "ðŸ“Š",
    "template": {
      "prompt": "You are a financial reporting specialist. Generate a detailed monthly expense report showing total expenses, breakdown by vendor, line item details with product descriptions, quantities, amounts, and GL categories for the specified month and year. Use postgres_inspect_schema first.",
      "trigger_type": "month_year",
      "input_fields": [
        {
          "name": "month",
          "type": "select",
          "label": "Month",
          "options": [
            "01",
            "02",
            "03",
            "04",
            "05",
            "06",
            "07",
            "08",
            "09",
            "10",
            "11",
            "12"
          ]
        },
        {
          "name": "year",
          "type": "text",
          "label": "Year",
          "placeholder": "2025"
        }
      ],
      "tools": [
        "postgres_query",
        "postgres_inspect_schema"
      ],
      "default_visualization_preferences": "bar chart showing monthly expenses by vendor, pie chart showing category distribution, line chart showing expense trends",
      "execution_guidance": {
        "query_template": {
          "base_query": "SELECT\n    d.batch_name AS batch_name,\n    (i.invoice_number->>'value')::text AS invoice_number,\n    (i.invoice_date->>'value')::text AS invoice_date,\n    (i.due_date->>'value')::text AS due_date,\n    NULLIF(i.total->>'value', '')::numeric AS invoice_total,\n    (i.sub_total->>'value')::text AS subtotal,\n    (i.tax->>'value')::text AS tax,\n    (i.payment_date->>'value')::text AS payment_date,\n    v.name AS vendor_name,\n    v.company AS vendor_company,\n    (ivd.description->>'value')::text AS product_description,\n    (ivd.item_code->>'value')::text AS item_code,\n    (ivd.quantity->>'value')::text AS quantity,\n    (ivd.unit_price->>'value')::text AS unit_price,\n    NULLIF(ivd.total_price->>'value', '')::numeric AS line_total,\n    tcm.name AS category_name,\n    g.name AS gl_name,\n    g.code AS gl_code\nFROM icap_invoice i\nLEFT JOIN icap_vendor v ON i.vendor_id = v.id\nINNER JOIN icap_document d ON i.document_id = d.id\nLEFT JOIN icap_invoice_detail ivd ON ivd.document_id = i.document_id\nLEFT JOIN icap_product_master pm ON NULLIF(ivd.product_id->>'value', '') IS NOT NULL AND (ivd.product_id->>'value')::uuid = pm.id\nLEFT JOIN icap_product_category_mapping pcm ON pm.id = pcm.product_id\nLEFT JOIN icap_tenant_category_master tcm ON pcm.gl_category_id = tcm.id\nLEFT JOIN icap_tenant_gl_category_mapping tgcm ON tcm.id = tgcm.category_id\nLEFT JOIN icap_gl g ON tgcm.gl_id = g.id\nWHERE i.invoice_date->>'value' LIKE '{month}/%/{year}'\nORDER BY i.invoice_number->>'value', ivd.id;",
          "parameters": [
            "month",
            "year"
          ],
          "param_instructions": "Extract 'month' (2-digit format 01-12) and 'year' (4-digit) from input_fields.",
          "description": "Complete monthly expense report with invoice headers, line item breakdowns, vendor info, and GL categories.",
          "where_clause": "WHERE i.invoice_date->>'value' LIKE '{month}/%/{year}'",
          "full_template": "SELECT\n    d.batch_name AS batch_name,\n    (i.invoice_number->>'value')::text AS invoice_number,\n    (i.invoice_date->>'value')::text AS invoice_date,\n    (i.due_date->>'value')::text AS due_date,\n    NULLIF(i.total->>'value', '')::numeric AS invoice_total,\n    (i.sub_total->>'value')::text AS subtotal,\n    (i.tax->>'value')::text AS tax,\n    (i.payment_date->>'value')::text AS payment_date,\n    v.name AS vendor_name,\n    v.company AS vendor_company,\n    (ivd.description->>'value')::text AS product_description,\n    (ivd.item_code->>'value')::text AS item_code,\n    (ivd.quantity->>'value')::text AS quantity,\n    (ivd.unit_price->>'value')::text AS unit_price,\n    NULLIF(ivd.total_price->>'value', '')::numeric AS line_total,\n    tcm.name AS category_name,\n    g.name AS gl_name,\n    g.code AS gl_code\nFROM icap_invoice i\nLEFT JOIN icap_vendor v ON i.vendor_id = v.id\nINNER JOIN icap_document d ON i.document_id = d.id\nLEFT JOIN icap_invoice_detail ivd ON ivd.document_id = i.document_id\nLEFT JOIN icap_product_master pm ON NULLIF(ivd.product_id->>'value', '') IS NOT NULL AND (ivd.product_id->>'value')::uuid = pm.id\nLEFT JOIN icap_product_category_mapping pcm ON pm.id = pcm.product_id\nLEFT JOIN icap_tenant_category_master tcm ON pcm.gl_category_id = tcm.id\nLEFT JOIN icap_tenant_gl_category_mapping tgcm ON tcm.id = tgcm.category_id\nLEFT JOIN icap_gl g ON tgcm.gl_id = g.id\nWHERE i.invoice_date->>'value' LIKE '{month}/%/{year}'\nORDER BY i.invoice_number->>'value', ivd.id;"
        },
        "execution_plan": {
          "step_1": "Load pre-built query template from execution_guidance",
          "step_2": "Extract 'month' (2-digit format 01-12) and 'year' (4-digit) from input_fields.",
          "step_3": "Replace template parameters: {month}, {year}",
          "step_4": "Execute filled query using postgres_query tool",
          "step_5": "Structure results as table_data with columns and rows arrays",
          "step_6": "Include row_count and column metadata",
          "step_7": "Return formatted table for interactive display"
        },
        "schema_context": "The database has been pre-inspected for your task. Key tables and columns:\n\n**Table: icap_invoice**\n- Columns (22): id, document_id, vendor_id, other_charges, credit_and_returns, invoice_number, invoice_date, due_date, tax, freight_charges, discount, total, sub_total, street, zip, city, country, state, payment_date, balance_amount, created_at, updated_at\n- JSONB columns (require ->> operator): other_charges, credit_and_returns, invoice_number, invoice_date, due_date, tax, freight_charges, discount, total, sub_total, street, zip, city, country, state, payment_date, balance_amount\n- Joins with: document_id â†’ icap_document, vendor_id â†’ icap_vendor\n- Related detail tables: icap_invoice_detail\n\n**Table: icap_invoice_detail**\n- Columns (13): id, document_id, uom, pack, size_numeric, size_unit, item_code, description, quantity, unit_price, total_price, category_id, product_id\n- JSONB columns (require ->> operator): uom, pack, size_numeric, size_unit, item_code, description, quantity, unit_price, total_price, category_id, product_id\n- Joins with: document_id â†’ icap_document\n\n**Table: icap_vendor**\n- Columns (11): id, tenant_id, name, company, address, email, active, created_by, modified_by, created_on, modified_on\n- Related detail tables: icap_invoice, icap_product_master\n\n**Table: icap_product_master**\n- Columns (8): id, product_code, name, created_on, tenant_id, product_code_id, vendor_id, external_product_id\n- Joins with: vendor_id â†’ icap_vendor\n\nâš ï¸ IMPORTANT: This is just a preview. You must still call postgres_inspect_schema() for each table before writing queries to get complete column lists and relationships.",
        "generated_at": "2026-01-02T18:48:34.480968",
        "configuration": {
          "trigger_type": "month_year",
          "output_format": "text",
          "prompt": "You are a financial reporting specialist. Generate a detailed monthly expense report showing total expenses, breakdown by vendor, line item details with product descriptions, quantities, amounts, and GL categories for the specified month and year. Use postgres_inspect_schema first."
        }
      }
    },
    "use_cases": [
      "Monthly financial reporting",
      "Budget tracking",
      "Expense analysis"
    ]
  },
  {
    "id": "vendor-spend-analyzer",
    "name": "Vendor Spend Analyzer",
    "description": "Analyze spending patterns across vendors to identify top suppliers and optimize procurement",
    "category": "Procurement",
    "icon": "ðŸ’°",
    "template": {
      "prompt": "You are a procurement analyst. Analyze vendor spending patterns by calculating total spend per vendor, number of invoices, average invoice amount, payment status distribution, and identify top vendors with detailed product breakdowns. Use postgres_inspect_schema first.",
      "trigger_type": "date_range",
      "input_fields": [
        {
          "name": "start_date",
          "type": "date",
          "label": "Start Date"
        },
        {
          "name": "end_date",
          "type": "date",
          "label": "End Date"
        }
      ],
      "tools": [
        "postgres_query",
        "postgres_inspect_schema"
      ],
      "default_visualization_preferences": "pie chart showing spend distribution by vendor, bar chart comparing total spend and invoice counts, line chart showing spending trends over time",
      "execution_guidance": {
        "query_template": {
          "base_query": "WITH vendor_summary AS (\n    SELECT\n        v.name AS vendor_name,\n        v.company AS vendor_company,\n,\n        v.address AS vendor_address,\n        COUNT(DISTINCT i.id) AS invoice_count,\n        SUM(CASE WHEN (i.total->>'value') != '' THEN (i.total->>'value')::numeric ELSE 0 END) AS total_spend,\n        AVG(CASE WHEN (i.total->>'value') != '' THEN (i.total->>'value')::numeric ELSE 0 END) AS avg_invoice_amount,\n        SUM(CASE WHEN i.payment_date->>'value' IS NOT NULL AND i.payment_date->>'value' != '' THEN 1 ELSE 0 END) AS paid_count,\n        SUM(CASE WHEN i.payment_date->>'value' IS NULL OR i.payment_date->>'value' = '' THEN 1 ELSE 0 END) AS unpaid_count\n    FROM icap_invoice i\n    LEFT JOIN icap_vendor v ON i.vendor_id = v.id\n    WHERE (i.invoice_date->>'value' >= '{start_date}' AND i.invoice_date->>'value' <= '{end_date}')\n    AND (i.total->>'value') IS NOT NULL\n    GROUP BY v.name, v.company, v.address\n)\nSELECT \n    vendor_name,\n    vendor_company,\n    \n    invoice_count,\n    total_spend,\n    ROUND(avg_invoice_amount, 2) AS avg_invoice_amount,\n    paid_count,\n    unpaid_count,\n    ROUND((total_spend / NULLIF((SELECT SUM(total_spend) FROM vendor_summary), 0)) * 100, 2) AS spend_percentage\nFROM vendor_summary\nORDER BY total_spend DESC;",
          "parameters": [
            "start_date",
            "end_date"
          ],
          "param_instructions": "Extract 'start_date' and 'end_date' from input_fields in MM/DD/YYYY format.",
          "description": "Comprehensive vendor spend analysis with totals, averages, payment distribution, and spend percentage ranking.",
          "where_clause": "WHERE (i.invoice_date->>'value' >= '{start_date}' AND i.invoice_date->>'value' <= '{end_date}')\n    GROUP BY v.name, v.company, v.address\n)\nSELECT \n    vendor_name,\n    vendor_company,\n    \n    invoice_count,\n    total_spend,\n    ROUND(avg_invoice_amount, 2) AS avg_invoice_amount,\n    paid_count,\n    unpaid_count,\n    ROUND((total_spend / NULLIF((SELECT SUM(total_spend) FROM vendor_summary), 0)) * 100, 2) AS spend_percentage\nFROM vendor_summary",
          "full_template": "WITH vendor_summary AS (\n    SELECT\n        v.name AS vendor_name,\n        v.company AS vendor_company,\n,\n        v.address AS vendor_address,\n        COUNT(DISTINCT i.id) AS invoice_count,\n        SUM(CASE WHEN (i.total->>'value') != '' THEN (i.total->>'value')::numeric ELSE 0 END) AS total_spend,\n        AVG(CASE WHEN (i.total->>'value') != '' THEN (i.total->>'value')::numeric ELSE 0 END) AS avg_invoice_amount,\n        SUM(CASE WHEN i.payment_date->>'value' IS NOT NULL AND i.payment_date->>'value' != '' THEN 1 ELSE 0 END) AS paid_count,\n        SUM(CASE WHEN i.payment_date->>'value' IS NULL OR i.payment_date->>'value' = '' THEN 1 ELSE 0 END) AS unpaid_count\n    FROM icap_invoice i\n    LEFT JOIN icap_vendor v ON i.vendor_id = v.id\n    WHERE (i.invoice_date->>'value' >= '{start_date}' AND i.invoice_date->>'value' <= '{end_date}')\n    AND (i.total->>'value') IS NOT NULL\n    GROUP BY v.name, v.company, v.address\n)\nSELECT \n    vendor_name,\n    vendor_company,\n    \n    invoice_count,\n    total_spend,\n    ROUND(avg_invoice_amount, 2) AS avg_invoice_amount,\n    paid_count,\n    unpaid_count,\n    ROUND((total_spend / NULLIF((SELECT SUM(total_spend) FROM vendor_summary), 0)) * 100, 2) AS spend_percentage\nFROM vendor_summary\nORDER BY total_spend DESC;"
        },
        "execution_plan": {
          "step_1": "Load pre-built query template from execution_guidance",
          "step_2": "Extract 'start_date' and 'end_date' from input_fields in MM/DD/YYYY format.",
          "step_3": "Replace template parameters: {start_date}, {end_date}",
          "step_4": "Execute filled query using postgres_query tool",
          "step_5": "Structure results as table_data with columns and rows arrays",
          "step_6": "Include row_count and column metadata",
          "step_7": "Return formatted table for interactive display"
        },
        "schema_context": "The database has been pre-inspected for your task. Key tables and columns:\n\n**Table: icap_invoice**\n- Columns (22): id, document_id, vendor_id, other_charges, credit_and_returns, invoice_number, invoice_date, due_date, tax, freight_charges, discount, total, sub_total, street, zip, city, country, state, payment_date, balance_amount, created_at, updated_at\n- JSONB columns (require ->> operator): other_charges, credit_and_returns, invoice_number, invoice_date, due_date, tax, freight_charges, discount, total, sub_total, street, zip, city, country, state, payment_date, balance_amount\n- Joins with: document_id â†’ icap_document, vendor_id â†’ icap_vendor\n- Related detail tables: icap_invoice_detail\n\n**Table: icap_invoice_detail**\n- Columns (13): id, document_id, uom, pack, size_numeric, size_unit, item_code, description, quantity, unit_price, total_price, category_id, product_id\n- JSONB columns (require ->> operator): uom, pack, size_numeric, size_unit, item_code, description, quantity, unit_price, total_price, category_id, product_id\n- Joins with: document_id â†’ icap_document\n\n**Table: icap_vendor**\n- Columns (11): id, tenant_id, name, company, address, email, active, created_by, modified_by, created_on, modified_on\n- Related detail tables: icap_invoice, icap_product_master\n\n**Table: icap_product_master**\n- Columns (8): id, product_code, name, created_on, tenant_id, product_code_id, vendor_id, external_product_id\n- Joins with: vendor_id â†’ icap_vendor\n\nâš ï¸ IMPORTANT: This is just a preview. You must still call postgres_inspect_schema() for each table before writing queries to get complete column lists and relationships.",
        "generated_at": "2026-01-02T18:48:34.480980",
        "configuration": {
          "trigger_type": "date_range",
          "output_format": "text",
          "prompt": "You are a procurement analyst. Analyze vendor spending patterns by calculating total spend per vendor, number of invoices, average invoice amount, payment status distribution, and identify top vendors with detailed product breakdowns. Use postgres_inspect_schema first."
        }
      }
    },
    "use_cases": [
      "Vendor performance review",
      "Negotiate better rates",
      "Consolidate suppliers"
    ]
  },
  {
    "id": "invoice-aging-report",
    "name": "Invoice Aging Report",
    "description": "Track unpaid invoices and identify overdue payments to improve cash flow management",
    "category": "Accounts Payable",
    "icon": "â°",
    "template": {
      "prompt": "You are an accounts payable specialist. Generate an aging report for unpaid invoices, categorizing them by age buckets (0-30 days, 31-60 days, 61-90 days, 90+ days). Include complete invoice details, vendor information, amounts, and days overdue. Use postgres_inspect_schema first.",
      "trigger_type": "text_query",
      "input_fields": [],
      "tools": [
        "postgres_query",
        "postgres_inspect_schema"
      ],
      "default_visualization_preferences": "bar chart showing aging buckets distribution, pie chart showing amounts by aging bucket, bar chart comparing overdue amounts by vendor",
      "execution_guidance": {
        "query_template": {
          "base_query": "SELECT\n    d.batch_name AS batch_name,\n    (i.invoice_number->>'value')::text AS invoice_number,\n    (i.invoice_date->>'value')::text AS invoice_date,\n    (i.due_date->>'value')::text AS due_date,\n    NULLIF(i.total->>'value', '')::numeric AS total_amount,\n    NULLIF(i.balance_amount->>'value', '')::numeric AS balance_due,\n    v.name AS vendor_name,\n    v.company AS vendor_company,\n,\n    CASE \n        WHEN (CURRENT_DATE - TO_DATE(i.due_date->>'value', 'MM/DD/YYYY')) <= 30 THEN '0-30 days'\n        WHEN (CURRENT_DATE - TO_DATE(i.due_date->>'value', 'MM/DD/YYYY')) BETWEEN 31 AND 60 THEN '31-60 days'\n        WHEN (CURRENT_DATE - TO_DATE(i.due_date->>'value', 'MM/DD/YYYY')) BETWEEN 61 AND 90 THEN '61-90 days'\n        WHEN (CURRENT_DATE - TO_DATE(i.due_date->>'value', 'MM/DD/YYYY')) > 90 THEN '90+ days'\n        ELSE 'Current'\n    END AS aging_bucket,\n    (CURRENT_DATE - TO_DATE(i.due_date->>'value', 'MM/DD/YYYY')) AS days_overdue\nFROM icap_invoice i\nLEFT JOIN icap_vendor v ON i.vendor_id = v.id\nINNER JOIN icap_document d ON i.document_id = d.id\nWHERE (i.payment_date->>'value' IS NULL OR i.payment_date->>'value' = '')\n    AND (i.balance_amount->>'value' IS NULL OR i.balance_amount->>'value' = '' OR (i.balance_amount->>'value')::numeric > 0)\nORDER BY days_overdue DESC, (i.total->>'value')::numeric DESC;",
          "parameters": [],
          "param_instructions": "No parameters required - analyzes all unpaid invoices.",
          "description": "Aging report showing unpaid invoices categorized by age buckets with days overdue calculation.",
          "where_clause": "WHERE (i.payment_date->>'value' IS NULL OR i.payment_date->>'value' = '')\n    AND (i.balance_amount->>'value' IS NULL OR i.balance_amount->>'value' = '' OR (i.balance_amount->>'value')::numeric > 0)",
          "full_template": "SELECT\n    d.batch_name AS batch_name,\n    (i.invoice_number->>'value')::text AS invoice_number,\n    (i.invoice_date->>'value')::text AS invoice_date,\n    (i.due_date->>'value')::text AS due_date,\n    NULLIF(i.total->>'value', '')::numeric AS total_amount,\n    NULLIF(i.balance_amount->>'value', '')::numeric AS balance_due,\n    v.name AS vendor_name,\n    v.company AS vendor_company,\n,\n    CASE \n        WHEN (CURRENT_DATE - TO_DATE(i.due_date->>'value', 'MM/DD/YYYY')) <= 30 THEN '0-30 days'\n        WHEN (CURRENT_DATE - TO_DATE(i.due_date->>'value', 'MM/DD/YYYY')) BETWEEN 31 AND 60 THEN '31-60 days'\n        WHEN (CURRENT_DATE - TO_DATE(i.due_date->>'value', 'MM/DD/YYYY')) BETWEEN 61 AND 90 THEN '61-90 days'\n        WHEN (CURRENT_DATE - TO_DATE(i.due_date->>'value', 'MM/DD/YYYY')) > 90 THEN '90+ days'\n        ELSE 'Current'\n    END AS aging_bucket,\n    (CURRENT_DATE - TO_DATE(i.due_date->>'value', 'MM/DD/YYYY')) AS days_overdue\nFROM icap_invoice i\nLEFT JOIN icap_vendor v ON i.vendor_id = v.id\nINNER JOIN icap_document d ON i.document_id = d.id\nWHERE (i.payment_date->>'value' IS NULL OR i.payment_date->>'value' = '')\n    AND (i.balance_amount->>'value' IS NULL OR i.balance_amount->>'value' = '' OR (i.balance_amount->>'value')::numeric > 0)\nORDER BY days_overdue DESC, (i.total->>'value')::numeric DESC;"
        },
        "execution_plan": {
          "step_1": "Load pre-built query template from execution_guidance",
          "step_2": "No parameters required",
          "step_3": "Execute query directly using postgres_query tool",
          "step_4": "Structure results as table_data with columns and rows arrays",
          "step_5": "Include row_count and column metadata",
          "step_6": "Return formatted table for interactive display"
        },
        "schema_context": "The database has been pre-inspected for your task. Key tables and columns:\n\n**Table: icap_invoice**\n- Columns (22): id, document_id, vendor_id, other_charges, credit_and_returns, invoice_number, invoice_date, due_date, tax, freight_charges, discount, total, sub_total, street, zip, city, country, state, payment_date, balance_amount, created_at, updated_at\n- JSONB columns (require ->> operator): other_charges, credit_and_returns, invoice_number, invoice_date, due_date, tax, freight_charges, discount, total, sub_total, street, zip, city, country, state, payment_date, balance_amount\n- Joins with: document_id â†’ icap_document, vendor_id â†’ icap_vendor\n- Related detail tables: icap_invoice_detail\n\n**Table: icap_invoice_detail**\n- Columns (13): id, document_id, uom, pack, size_numeric, size_unit, item_code, description, quantity, unit_price, total_price, category_id, product_id\n- JSONB columns (require ->> operator): uom, pack, size_numeric, size_unit, item_code, description, quantity, unit_price, total_price, category_id, product_id\n- Joins with: document_id â†’ icap_document\n\n**Table: icap_vendor**\n- Columns (11): id, tenant_id, name, company, address, email, active, created_by, modified_by, created_on, modified_on\n- Related detail tables: icap_invoice, icap_product_master\n\n**Table: icap_product_master**\n- Columns (8): id, product_code, name, created_on, tenant_id, product_code_id, vendor_id, external_product_id\n- Joins with: vendor_id â†’ icap_vendor\n\nâš ï¸ IMPORTANT: This is just a preview. You must still call postgres_inspect_schema() for each table before writing queries to get complete column lists and relationships.",
        "generated_at": "2026-01-02T18:48:34.480991",
        "configuration": {
          "trigger_type": "text_query",
          "output_format": "text",
          "prompt": "You are an accounts payable specialist. Generate an aging report for unpaid invoices, categorizing them by age buckets (0-30 days, 31-60 days, 61-90 days, 90+ days). Include complete invoice details, vendor information, amounts, and days overdue. Use postgres_inspect_schema first."
        }
      }
    },
    "use_cases": [
      "Cash flow management",
      "Payment prioritization",
      "Vendor relationship management"
    ]
  },
  {
    "id": "tax-calculation-validator",
    "name": "Tax Calculation Validator",
    "description": "Validate tax calculations on invoices to ensure accuracy and compliance",
    "category": "Finance & Accounting",
    "icon": "ðŸ§®",
    "template": {
      "prompt": "You are a tax validation specialist. Review invoices and verify that tax amounts are correctly calculated based on subtotal. Flag any discrepancies where calculated tax doesn't match reported tax. Include invoice details, vendor info, and variance analysis. Use postgres_inspect_schema first.",
      "trigger_type": "month_year",
      "input_fields": [
        {
          "name": "month",
          "type": "select",
          "label": "Month",
          "options": [
            "01",
            "02",
            "03",
            "04",
            "05",
            "06",
            "07",
            "08",
            "09",
            "10",
            "11",
            "12"
          ]
        },
        {
          "name": "year",
          "type": "text",
          "label": "Year",
          "placeholder": "2025"
        }
      ],
      "tools": [
        "postgres_query",
        "postgres_inspect_schema"
      ],
      "default_visualization_preferences": "pie chart showing validation status distribution, bar chart comparing reported vs calculated tax, scatter plot showing tax variance",
      "execution_guidance": {
        "query_template": {
          "base_query": "SELECT\n    d.batch_name AS batch_name,\n    (i.invoice_number->>'value')::text AS invoice_number,\n    (i.invoice_date->>'value')::text AS invoice_date,\n    v.name AS vendor_name,\n    v.company AS vendor_company,\n    CASE WHEN (i.sub_total->>'value') != '' AND (i.sub_total->>'value') IS NOT NULL THEN (i.sub_total->>'value')::numeric ELSE NULL END AS subtotal,\n    CASE WHEN (i.tax->>'value') != '' AND (i.tax->>'value') IS NOT NULL THEN (i.tax->>'value')::numeric ELSE NULL END AS reported_tax,\n    CASE WHEN (i.total->>'value') != '' AND (i.total->>'value') IS NOT NULL THEN (i.total->>'value')::numeric ELSE NULL END AS total,\n    CASE \n        WHEN (i.sub_total->>'value') = '' OR (i.sub_total->>'value') IS NULL THEN NULL\n        ELSE ROUND((i.sub_total->>'value')::numeric * 0.10, 2)\n    END AS calculated_tax_10pct,\n    CASE \n        WHEN (i.tax->>'value') = '' OR (i.tax->>'value') IS NULL OR (i.sub_total->>'value') = '' OR (i.sub_total->>'value') IS NULL THEN NULL\n        ELSE ROUND((i.tax->>'value')::numeric - ((i.sub_total->>'value')::numeric * 0.10), 2)\n    END AS tax_variance,\n    CASE \n        WHEN (i.tax->>'value') = '' OR (i.tax->>'value') IS NULL OR (i.sub_total->>'value') = '' OR (i.sub_total->>'value') IS NULL THEN 'N/A'\n        WHEN ABS((i.tax->>'value')::numeric - ((i.sub_total->>'value')::numeric * 0.10)) < 0.01 THEN 'Valid'\n        WHEN ABS((i.tax->>'value')::numeric - ((i.sub_total->>'value')::numeric * 0.10)) <= 1.00 THEN 'Minor Variance'\n        ELSE 'Significant Variance'\n    END AS validation_status\nFROM icap_invoice i\nLEFT JOIN icap_vendor v ON i.vendor_id = v.id\nINNER JOIN icap_document d ON i.document_id = d.id\nWHERE i.invoice_date->>'value' LIKE '{month}/%/{year}'\n    AND (i.tax->>'value' IS NOT NULL AND i.tax->>'value' != '' AND (i.tax->>'value')::numeric > 0)\nORDER BY \n    CASE \n        WHEN (i.tax->>'value') = '' OR (i.tax->>'value') IS NULL OR (i.sub_total->>'value') = '' OR (i.sub_total->>'value') IS NULL THEN 4\n        WHEN ABS((i.tax->>'value')::numeric - ((i.sub_total->>'value')::numeric * 0.10)) > 1.00 THEN 1\n        WHEN ABS((i.tax->>'value')::numeric - ((i.sub_total->>'value')::numeric * 0.10)) > 0.01 THEN 2\n        ELSE 3\n    END,\n    CASE \n        WHEN (i.tax->>'value') = '' OR (i.tax->>'value') IS NULL OR (i.sub_total->>'value') = '' OR (i.sub_total->>'value') IS NULL THEN 0\n        ELSE ABS((i.tax->>'value')::numeric - ((i.sub_total->>'value')::numeric * 0.10))\n    END DESC;",
          "parameters": [
            "month",
            "year"
          ],
          "param_instructions": "Extract 'month' (2-digit) and 'year' (4-digit) from input_fields. Assumes 10% tax rate (adjust as needed).",
          "description": "Tax validation showing reported vs calculated tax with variance analysis and validation status.",
          "where_clause": "WHERE i.invoice_date->>'value' LIKE '{month}/%/{year}'\n    AND (i.tax->>'value' IS NOT NULL AND i.tax->>'value' != '' AND (i.tax->>'value')::numeric > 0)",
          "full_template": "SELECT\n    d.batch_name AS batch_name,\n    (i.invoice_number->>'value')::text AS invoice_number,\n    (i.invoice_date->>'value')::text AS invoice_date,\n    v.name AS vendor_name,\n    v.company AS vendor_company,\n    CASE WHEN (i.sub_total->>'value') != '' AND (i.sub_total->>'value') IS NOT NULL THEN (i.sub_total->>'value')::numeric ELSE NULL END AS subtotal,\n    CASE WHEN (i.tax->>'value') != '' AND (i.tax->>'value') IS NOT NULL THEN (i.tax->>'value')::numeric ELSE NULL END AS reported_tax,\n    CASE WHEN (i.total->>'value') != '' AND (i.total->>'value') IS NOT NULL THEN (i.total->>'value')::numeric ELSE NULL END AS total,\n    CASE \n        WHEN (i.sub_total->>'value') = '' OR (i.sub_total->>'value') IS NULL THEN NULL\n        ELSE ROUND((i.sub_total->>'value')::numeric * 0.10, 2)\n    END AS calculated_tax_10pct,\n    CASE \n        WHEN (i.tax->>'value') = '' OR (i.tax->>'value') IS NULL OR (i.sub_total->>'value') = '' OR (i.sub_total->>'value') IS NULL THEN NULL\n        ELSE ROUND((i.tax->>'value')::numeric - ((i.sub_total->>'value')::numeric * 0.10), 2)\n    END AS tax_variance,\n    CASE \n        WHEN (i.tax->>'value') = '' OR (i.tax->>'value') IS NULL OR (i.sub_total->>'value') = '' OR (i.sub_total->>'value') IS NULL THEN 'N/A'\n        WHEN ABS((i.tax->>'value')::numeric - ((i.sub_total->>'value')::numeric * 0.10)) < 0.01 THEN 'Valid'\n        WHEN ABS((i.tax->>'value')::numeric - ((i.sub_total->>'value')::numeric * 0.10)) <= 1.00 THEN 'Minor Variance'\n        ELSE 'Significant Variance'\n    END AS validation_status\nFROM icap_invoice i\nLEFT JOIN icap_vendor v ON i.vendor_id = v.id\nINNER JOIN icap_document d ON i.document_id = d.id\nWHERE i.invoice_date->>'value' LIKE '{month}/%/{year}'\n    AND (i.tax->>'value' IS NOT NULL AND i.tax->>'value' != '' AND (i.tax->>'value')::numeric > 0)\nORDER BY \n    CASE \n        WHEN (i.tax->>'value') = '' OR (i.tax->>'value') IS NULL OR (i.sub_total->>'value') = '' OR (i.sub_total->>'value') IS NULL THEN 4\n        WHEN ABS((i.tax->>'value')::numeric - ((i.sub_total->>'value')::numeric * 0.10)) > 1.00 THEN 1\n        WHEN ABS((i.tax->>'value')::numeric - ((i.sub_total->>'value')::numeric * 0.10)) > 0.01 THEN 2\n        ELSE 3\n    END,\n    CASE \n        WHEN (i.tax->>'value') = '' OR (i.tax->>'value') IS NULL OR (i.sub_total->>'value') = '' OR (i.sub_total->>'value') IS NULL THEN 0\n        ELSE ABS((i.tax->>'value')::numeric - ((i.sub_total->>'value')::numeric * 0.10))\n    END DESC;"
        },
        "execution_plan": {
          "step_1": "Load pre-built query template from execution_guidance",
          "step_2": "Extract 'month' (2-digit) and 'year' (4-digit) from input_fields. Assumes 10% tax rate (adjust as needed).",
          "step_3": "Replace template parameters: {month}, {year}",
          "step_4": "Execute filled query using postgres_query tool",
          "step_5": "Structure results as table_data with columns and rows arrays",
          "step_6": "Include row_count and column metadata",
          "step_7": "Return formatted table for interactive display"
        },
        "schema_context": "The database has been pre-inspected for your task. Key tables and columns:\n\n**Table: icap_invoice**\n- Columns (22): id, document_id, vendor_id, other_charges, credit_and_returns, invoice_number, invoice_date, due_date, tax, freight_charges, discount, total, sub_total, street, zip, city, country, state, payment_date, balance_amount, created_at, updated_at\n- JSONB columns (require ->> operator): other_charges, credit_and_returns, invoice_number, invoice_date, due_date, tax, freight_charges, discount, total, sub_total, street, zip, city, country, state, payment_date, balance_amount\n- Joins with: document_id â†’ icap_document, vendor_id â†’ icap_vendor\n- Related detail tables: icap_invoice_detail\n\n**Table: icap_invoice_detail**\n- Columns (13): id, document_id, uom, pack, size_numeric, size_unit, item_code, description, quantity, unit_price, total_price, category_id, product_id\n- JSONB columns (require ->> operator): uom, pack, size_numeric, size_unit, item_code, description, quantity, unit_price, total_price, category_id, product_id\n- Joins with: document_id â†’ icap_document\n\n**Table: icap_vendor**\n- Columns (11): id, tenant_id, name, company, address, email, active, created_by, modified_by, created_on, modified_on\n- Related detail tables: icap_invoice, icap_product_master\n\n**Table: icap_product_master**\n- Columns (8): id, product_code, name, created_on, tenant_id, product_code_id, vendor_id, external_product_id\n- Joins with: vendor_id â†’ icap_vendor\n\nâš ï¸ IMPORTANT: This is just a preview. You must still call postgres_inspect_schema() for each table before writing queries to get complete column lists and relationships.",
        "generated_at": "2026-01-02T18:48:34.481004",
        "configuration": {
          "trigger_type": "month_year",
          "output_format": "text",
          "prompt": "You are a tax validation specialist. Review invoices and verify that tax amounts are correctly calculated based on subtotal. Flag any discrepancies where calculated tax doesn't match reported tax. Include invoice details, vendor info, and variance analysis. Use postgres_inspect_schema first."
        }
      }
    },
    "use_cases": [
      "Tax compliance",
      "Audit preparation",
      "Invoice error detection"
    ]
  },
  {
    "id": "product-category-spend",
    "name": "Product Category Spend Analysis",
    "description": "Analyze spending by product categories with GL mappings and vendor breakdown",
    "category": "Analytics",
    "icon": "ðŸ“ˆ",
    "template": {
      "prompt": "You are a category spend analyst. Analyze spending patterns across product categories using GL category mappings. Show total spend per category, number of invoices, line items, vendors contributing to each category, and detailed product breakdowns. Use postgres_inspect_schema first.",
      "trigger_type": "date_range",
      "input_fields": [
        {
          "name": "start_date",
          "type": "date",
          "label": "Start Date"
        },
        {
          "name": "end_date",
          "type": "date",
          "label": "End Date"
        }
      ],
      "tools": [
        "postgres_query",
        "postgres_inspect_schema"
      ],
      "default_visualization_preferences": "pie chart showing spend distribution by category, bar chart comparing category totals, bar chart showing top products by spend",
      "execution_guidance": {
        "query_template": {
          "base_query": "SELECT\n    d.batch_name AS batch_name,\n    pm.name AS product_name,\n    pm.product_code AS product_code,\n    tcm.name AS category_name,\n    g.name AS gl_name,\n    g.code AS gl_code,\n    (ivd.description->>'value')::text AS product_description,\n    (ivd.item_code->>'value')::text AS item_code,\n    v.name AS vendor_name,\n    CASE WHEN (ivd.unit_price->>'value') != '' THEN (ivd.unit_price->>'value')::numeric ELSE 0 END AS item_unit_price,\n    CASE WHEN (ivd.quantity->>'value') != '' THEN (ivd.quantity->>'value')::numeric ELSE 0 END AS quantity,\n    i.invoice_date->>'value' AS invoice_date\nFROM icap_invoice_detail ivd\nLEFT JOIN icap_invoice i ON ivd.document_id = i.document_id\nINNER JOIN icap_document d ON i.document_id = d.id\nLEFT JOIN icap_vendor v ON i.vendor_id = v.id\nLEFT JOIN icap_product_master pm ON (ivd.product_id->>'value') != '' AND (ivd.product_id->>'value')::uuid = pm.id\nLEFT JOIN icap_product_category_mapping pcm ON pm.id = pcm.product_id\nLEFT JOIN icap_tenant_category_master tcm ON pcm.gl_category_id = tcm.id\nLEFT JOIN icap_tenant_gl_category_mapping tgcm ON tcm.id = tgcm.category_id\nLEFT JOIN icap_gl g ON tgcm.gl_id = g.id\nWHERE TO_DATE(i.invoice_date->>'value', 'MM/DD/YYYY') BETWEEN TO_DATE('{start_date}', 'MM/DD/YYYY') AND TO_DATE('{end_date}', 'MM/DD/YYYY')\nORDER BY item_unit_price DESC;",
          "parameters": [
            "start_date",
            "end_date"
          ],
          "param_instructions": "Extract 'start_date' and 'end_date' from input_fields in MM/DD/YYYY format.",
          "description": "Category-level spend analysis with product details, vendor breakdown, quantities, and spend percentage distribution.",
          "where_clause": "WHERE (i.invoice_date->>'value' >= '{start_date}' AND i.invoice_date->>'value' <= '{end_date}')\n    GROUP BY \n        pm.name,\n        pm.product_code,\n        tcm.name,\n        g.name,\n        g.code,\n        (ivd.description->>'value')::text,\n        (ivd.item_code->>'value')::text,\n        v.name\n)\nSELECT\n    product_name,\n    product_code,\n    category_name,\n    gl_name,\n    gl_code,\n    product_description,\n    item_code,\n    vendor_name,\n    category_spend,\n    invoice_count,\n    line_item_count,\n    total_quantity,\n    ROUND((category_spend / NULLIF((SELECT SUM(category_spend) FROM category_spend), 0)) * 100, 2) AS spend_percentage\nFROM category_spend",
          "full_template": "SELECT\n    d.batch_name AS batch_name,\n    pm.name AS product_name,\n    pm.product_code AS product_code,\n    tcm.name AS category_name,\n    g.name AS gl_name,\n    g.code AS gl_code,\n    (ivd.description->>'value')::text AS product_description,\n    (ivd.item_code->>'value')::text AS item_code,\n    v.name AS vendor_name,\n    CASE WHEN (ivd.unit_price->>'value') != '' THEN (ivd.unit_price->>'value')::numeric ELSE 0 END AS item_unit_price,\n    CASE WHEN (ivd.quantity->>'value') != '' THEN (ivd.quantity->>'value')::numeric ELSE 0 END AS quantity,\n    i.invoice_date->>'value' AS invoice_date\nFROM icap_invoice_detail ivd\nLEFT JOIN icap_invoice i ON ivd.document_id = i.document_id\nINNER JOIN icap_document d ON i.document_id = d.id\nLEFT JOIN icap_vendor v ON i.vendor_id = v.id\nLEFT JOIN icap_product_master pm ON (ivd.product_id->>'value') != '' AND (ivd.product_id->>'value')::uuid = pm.id\nLEFT JOIN icap_product_category_mapping pcm ON pm.id = pcm.product_id\nLEFT JOIN icap_tenant_category_master tcm ON pcm.gl_category_id = tcm.id\nLEFT JOIN icap_tenant_gl_category_mapping tgcm ON tcm.id = tgcm.category_id\nLEFT JOIN icap_gl g ON tgcm.gl_id = g.id\nWHERE TO_DATE(i.invoice_date->>'value', 'MM/DD/YYYY') BETWEEN TO_DATE('{start_date}', 'MM/DD/YYYY') AND TO_DATE('{end_date}', 'MM/DD/YYYY')\nORDER BY item_unit_price DESC;"
        },
        "execution_plan": {
          "step_1": "Load pre-built query template from execution_guidance",
          "step_2": "Extract 'start_date' and 'end_date' from input_fields in MM/DD/YYYY format.",
          "step_3": "Replace template parameters: {start_date}, {end_date}",
          "step_4": "Execute filled query using postgres_query tool",
          "step_5": "Structure results as table_data with columns and rows arrays",
          "step_6": "Include row_count and column metadata",
          "step_7": "Return formatted table for interactive display"
        },
        "schema_context": "The database has been pre-inspected for your task. Key tables and columns:\n\n**Table: icap_invoice**\n- Columns (22): id, document_id, vendor_id, other_charges, credit_and_returns, invoice_number, invoice_date, due_date, tax, freight_charges, discount, total, sub_total, street, zip, city, country, state, payment_date, balance_amount, created_at, updated_at\n- JSONB columns (require ->> operator): other_charges, credit_and_returns, invoice_number, invoice_date, due_date, tax, freight_charges, discount, total, sub_total, street, zip, city, country, state, payment_date, balance_amount\n- Joins with: document_id â†’ icap_document, vendor_id â†’ icap_vendor\n- Related detail tables: icap_invoice_detail\n\n**Table: icap_invoice_detail**\n- Columns (13): id, document_id, uom, pack, size_numeric, size_unit, item_code, description, quantity, unit_price, total_price, category_id, product_id\n- JSONB columns (require ->> operator): uom, pack, size_numeric, size_unit, item_code, description, quantity, unit_price, total_price, category_id, product_id\n- Joins with: document_id â†’ icap_document\n\n**Table: icap_vendor**\n- Columns (11): id, tenant_id, name, company, address, email, active, created_by, modified_by, created_on, modified_on\n- Related detail tables: icap_invoice, icap_product_master\n\n**Table: icap_product_master**\n- Columns (8): id, product_code, name, created_on, tenant_id, product_code_id, vendor_id, external_product_id\n- Joins with: vendor_id â†’ icap_vendor\n\nâš ï¸ IMPORTANT: This is just a preview. You must still call postgres_inspect_schema() for each table before writing queries to get complete column lists and relationships.",
        "generated_at": "2026-01-02T18:48:34.481016",
        "configuration": {
          "trigger_type": "date_range",
          "output_format": "text",
          "prompt": "You are a category spend analyst. Analyze spending patterns across product categories using GL category mappings. Show total spend per category, number of invoices, line items, vendors contributing to each category, and detailed product breakdowns. Use postgres_inspect_schema first."
        }
      }
    },
    "use_cases": [
      "Category management",
      "Budget allocation by category",
      "Vendor consolidation by category"
    ]
  }
]